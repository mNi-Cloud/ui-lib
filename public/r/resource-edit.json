{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "resource-edit",
  "type": "registry:component",
  "title": "Resource Edit",
  "description": "A resource editing form component.",
  "dependencies": [
    "next-intl",
    "@hookform/resolvers",
    "react-hook-form",
    "sonner",
    "zod"
  ],
  "registryDependencies": [
    "form",
    "card",
    "input",
    "select",
    "button",
    "alert"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/resource-edit/resource-edit.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { Card, CardContent } from '@/registry/new-york/ui/card';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { Input } from '@/registry/new-york/ui/input';\nimport { AlertCircle, X } from 'lucide-react';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/registry/new-york/ui/select';\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n  FormDescription,\n} from '@/registry/new-york/ui/form';\nimport { Alert, AlertDescription } from '@/registry/new-york/ui/alert';\nimport { useFieldArray, useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { toast } from 'sonner';\nimport { useTranslations } from 'next-intl';\n\ntype ValidationPattern = {\n  value: string;\n  flags?: string;\n  message: string;\n};\n\ntype SelectOption = {\n  value: string;\n  label: string;\n};\n\ntype BaseFieldValidation = {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: ValidationPattern;\n  valueAsNumber?: boolean;\n};\n\ntype BaseFieldDefinition = {\n  name: string;\n  label: string;\n  placeholder?: string;\n  description?: string;\n  validation?: BaseFieldValidation;\n  disabled?: boolean;\n  readOnly?: boolean;\n  readOnlyMessage?: string;\n  onChange?: (value: any) => void;\n};\n\ntype TextFieldDefinition = BaseFieldDefinition & {\n  type: 'text' | 'number' | 'email' | 'password';\n};\n\ntype SelectFieldDefinition = BaseFieldDefinition & {\n  type: 'select';\n  options: SelectOption[];\n};\n\ntype ArrayFieldObjectDefinition = BaseFieldDefinition & {\n  type: 'text' | 'number' | 'email' | 'password' | 'select';\n  options?: SelectOption[];\n};\n\ntype ArrayFieldDefinition = BaseFieldDefinition & {\n  type: 'array';\n  itemType: 'text' | 'object';\n  fields?: ArrayFieldObjectDefinition[];\n};\n\ntype FieldDefinition = TextFieldDefinition | SelectFieldDefinition | ArrayFieldDefinition;\n\ntype ResourceEditProps = {\n  title: string;\n  resourceType: string;\n  fields: FieldDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  resourceId: string;\n  successMessage?: string;\n  errorMessage?: string;\n  onTypeChange?: (newType: string) => void;\n  formatFormData?: (data: any) => any;\n};\n\ninterface ArrayItemRecord {\n  [key: string]: string | number | null;\n}\n\nconst ArrayFieldComponent: React.FC<{\n  form: any;\n  field: ArrayFieldDefinition;\n}> = ({ form, field }) => {\n  const t = useTranslations('component.resource-edit');\n\n  const { fields, append, remove } = useFieldArray({\n    control: form.control,\n    name: field.name,\n  });\n\n  const addNewItem = () => {\n    if (field.itemType === 'object' && field.fields) {\n      const newItem = field.fields.reduce<Record<string, any>>((acc, fieldItem) => {\n        acc[fieldItem.name] = fieldItem.type === 'number' ? null : '';\n        return acc;\n      }, {});\n      append(newItem);\n    } else {\n      append('');\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <FormLabel>\n          {field.label}\n          {field.validation?.required && (\n            <span className=\"text-destructive ml-1\">*</span>\n          )}\n        </FormLabel>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={addNewItem}\n          disabled={field.readOnly}\n        >\n          {t('add')}\n        </Button>\n      </div>\n\n      {fields.map((arrayField, index) => (\n        <div key={arrayField.id} className=\"relative\">\n          {field.itemType === 'object' ? (\n            <div className=\"flex gap-4 items-start\">\n              {field.fields?.map((subField) => (\n                <FormField\n                  key={`${arrayField.id}-${subField.name}`}\n                  control={form.control}\n                  name={`${field.name}.${index}.${subField.name}`}\n                  render={({ field: formField }) => (\n                    <FormItem className=\"flex-1\">\n                      <FormLabel>{subField.label}</FormLabel>\n                      <FormControl>\n                        {subField.type === 'select' ? (\n                          <Select\n                            value={formField.value?.toString() || ''}\n                            onValueChange={(value) => {\n                              formField.onChange(value);\n                              if (subField.onChange) {\n                                subField.onChange(value);\n                              }\n                            }}\n                            disabled={subField.disabled || field.readOnly}\n                          >\n                            <SelectTrigger className={field.readOnly ? 'bg-muted' : ''}>\n                              <SelectValue\n                                placeholder={subField.placeholder || t('select', { label: subField.label })}\n                              />\n                            </SelectTrigger>\n                            <SelectContent>\n                              {subField.options?.map((option) => (\n                                <SelectItem\n                                  key={`${subField.name}-${index}-option-${option.value}`}\n                                  value={option.value}\n                                >\n                                  {option.label}\n                                </SelectItem>\n                              ))}\n                            </SelectContent>\n                          </Select>\n                        ) : (\n                          <Input\n                            type={subField.type}\n                            placeholder={subField.placeholder}\n                            className={field.readOnly ? 'bg-muted' : ''}\n                            disabled={subField.disabled || field.readOnly}\n                            value={formField.value ?? ''}\n                            onChange={(e) => {\n                              const value = subField.type === 'number'\n                                ? e.target.value === '' ? null : Number(e.target.value)\n                                : e.target.value;\n                              formField.onChange(value);\n                              if (subField.onChange) {\n                                subField.onChange(value);\n                              }\n                            }}\n                          />\n                        )}\n                      </FormControl>\n                      <FormMessage />\n                      {subField.description && (\n                        <FormDescription>{subField.description}</FormDescription>\n                      )}\n                    </FormItem>\n                  )}\n                />\n              ))}\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"mt-8\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          ) : (\n            <div className=\"flex gap-2\">\n              <FormField\n                control={form.control}\n                name={`${field.name}.${index}`}\n                render={({ field: formField }) => (\n                  <FormItem className=\"flex-1\">\n                    <FormControl>\n                      <Input\n                        className={field.readOnly ? 'bg-muted' : ''}\n                        readOnly={field.readOnly}\n                        {...formField}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n      {field.description && (\n        <p className=\"text-sm text-muted-foreground\">\n          {field.description}\n        </p>\n      )}\n    </div>\n  );\n};\n\nconst ResourceEdit: React.FC<ResourceEditProps> = ({\n  title,\n  resourceType,\n  fields,\n  apiEndpoint,\n  redirectPath,\n  resourceId,\n  successMessage,\n  errorMessage,\n  onTypeChange,\n  formatFormData,\n}) => {\n  const router = useRouter();\n  const [loading, setLoading] = useState(false);\n  const [initialLoading, setInitialLoading] = useState(true);\n  const t = useTranslations('component.resource-edit');\n\n  const messages = {\n    success: successMessage || t('successmessage'),\n    error: errorMessage || t('errormessage')\n  };\n\n  const getNestedValue = (obj: Record<string, any>, path: string): any => {\n    return path.split('.').reduce((acc: any, part: string) => {\n      return acc && typeof acc === 'object' ? acc[part] : undefined;\n    }, obj);\n  };\n\n  const setNestedValue = (obj: Record<string, any>, path: string[], value: any) => {\n    let current = obj;\n    for (let i = 0; i < path.length - 1; i++) {\n      const key = path[i];\n      if (key) {\n        if (!current[key]) current[key] = {};\n        current = current[key];\n      }\n    }\n    const lastKey = path[path.length - 1];\n    if (lastKey) current[lastKey] = value;\n    return obj;\n  };\n\n  const generateZodSchema = (fields: FieldDefinition[]) => {\n    const schemaObject: Record<string, any> = {};\n\n    const createFieldSchema = (field: BaseFieldDefinition, type: string) => {\n      if (type === 'number') {\n        let schema = z.coerce.number();\n        if (field.validation?.min !== undefined) {\n          schema = schema.min(field.validation.min);\n        }\n        if (field.validation?.max !== undefined) {\n          schema = schema.max(field.validation.max);\n        }\n        return field.validation?.required ? schema : schema.nullable().optional();\n      }\n\n      let schema = z.string();\n      if (field.validation?.pattern) {\n        const regex = new RegExp(\n          field.validation.pattern.value,\n          field.validation.pattern.flags\n        );\n        schema = schema.regex(regex, field.validation.pattern.message);\n      }\n\n      if (field.validation?.maxLength) {\n        schema = schema.max(\n          field.validation.maxLength,\n          t('textlesser', { label: field.label, maxLength: field.validation.maxLength })\n        );\n      }\n\n      return field.validation?.required \n        ? schema.min(1, t('need', { label: field.label })) \n        : schema.optional();\n    };\n\n    const processNestedFields = (currentObj: any, path: string[], field: FieldDefinition) => {\n      const [current, ...remaining] = path;\n      \n      if (!current) return;\n\n      if (remaining.length > 0) {\n        currentObj[current] = currentObj[current] || {};\n        processNestedFields(currentObj[current], remaining, field);\n      } else {\n        if (field.type === 'array') {\n          const arraySchema = field.itemType === 'object' && field.fields\n            ? z.array(z.object(\n                field.fields.reduce((acc: Record<string, any>, subField) => {\n                  acc[subField.name] = createFieldSchema(subField, subField.type);\n                  return acc;\n                }, {})\n              ))\n            : z.array(z.string());\n          \n          currentObj[current] = field.validation?.required \n            ? arraySchema \n            : arraySchema.optional();\n        } else {\n          currentObj[current] = createFieldSchema(field, field.type);\n        }\n      }\n    };\n\n    fields.forEach(field => {\n      const path = field.name.split('.');\n      processNestedFields(schemaObject, path, field);\n    });\n\n    const processNestedSchema = (obj: any): any => {\n      const processed: { [key: string]: any } = {};\n      for (const [key, value] of Object.entries(obj)) {\n        processed[key] = typeof value === 'object' && !(value instanceof z.ZodType)\n          ? z.object(processNestedSchema(value))\n          : value;\n      }\n      return processed;\n    };\n\n    return z.object(processNestedSchema(schemaObject));\n  };\n\n  const formSchema = generateZodSchema(fields);\n  type FormValues = z.infer<typeof formSchema>;\n\n  const form = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: fields.reduce((acc: Record<string, any>, field) => {\n      const fieldPath = field.name.split('.');\n      const defaultValue = field.type === 'array' ? [] : field.type === 'number' ? null : '';\n      return setNestedValue(acc, fieldPath, defaultValue);\n    }, {}),\n  });\n\n  useEffect(() => {\n    const fetchResource = async () => {\n      try {\n        const response = await fetch(`${apiEndpoint}/${resourceId}`);\n        if (!response.ok) throw new Error(t('fetcherror'));\n        const data = await response.json();\n\n        fields.forEach((field) => {\n          const value = getNestedValue(data, field.name);\n          if (value !== undefined) {\n            if (field.type === 'array') {\n              form.setValue(field.name, value.map((item: any) => \n                field.itemType === 'object' \n                  ? field.fields?.reduce((acc, subField) => {\n                      acc[subField.name] = item[subField.name] ?? '';\n                      return acc;\n                    }, {} as Record<string, any>)\n                  : item\n              ));\n            } else {\n              form.setValue(field.name, field.type === 'number' ? Number(value) : value);\n            }\n          }\n        });\n      } catch (error) {\n        toast.error(t('error'), { description: t('fetcherror'), duration: 5000 });\n        router.push(redirectPath);\n      } finally {\n        setInitialLoading(false);\n      }\n    };\n\n    fetchResource();\n  }, [apiEndpoint, resourceId, form, router, redirectPath, fields, t]);\n\n  const filterReadOnlyFields = (data: FormValues): Partial<FormValues> => {\n    const processNested = (currentData: any, fieldPath: string[]): any => {\n      const [current, ...remaining] = fieldPath;\n      \n      if (!current || !currentData) return {};\n\n      if (remaining.length > 0) {\n        return {\n          [current]: processNested(currentData[current] || {}, remaining)\n        };\n      }\n      \n      return { [current]: currentData[current] };\n    };\n\n    return fields.reduce((acc, field) => {\n      if (!field.readOnly) {\n        const value = getNestedValue(data, field.name);\n        if (value !== undefined) {\n          return setNestedValue(acc, field.name.split('.'), value);\n        }\n      }\n      return acc;\n    }, {} as Record<string, any>);\n  };\n\n  const onSubmit = async (values: FormValues) => {\n    setLoading(true);\n    try {\n      const filteredData = filterReadOnlyFields(values);\n      const formattedData = formatFormData ? formatFormData(filteredData) : filteredData;\n      const response = await fetch(`${apiEndpoint}/${resourceId}`, {\n        method: 'PATCH',\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n        body: JSON.stringify(formattedData),\n      });\n\n      if (!response.ok) throw new Error(messages.error);\n\n      let resourceName = '';\n      if (formattedData && typeof formattedData === 'object' && 'name' in formattedData) {\n        resourceName = String(formattedData.name);\n      } else if (fields[0]) {\n        resourceName = String(getNestedValue(values, fields[0].name));\n      }\n\n      toast.success(messages.success, {\n        description: `${resourceType} ${t('updated', { resourceName })}`,\n        duration: 5000,\n      });\n      router.push(redirectPath);\n    } catch (error) {\n      toast.error(t('error'), {\n        description: messages.error,\n        duration: 5000,\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const onCancel = () => {\n    router.push(redirectPath);\n    toast.info(t('canceledit'), {\n      duration: 3000,\n    });\n  };\n\n  const typeValue = form.watch('type');\n  useEffect(() => {\n    if (typeValue && onTypeChange) {\n      onTypeChange(typeValue);\n    }\n  }, [typeValue, onTypeChange]);\n\n  const renderFormField = (field: FieldDefinition) => {\n    if (field.type === 'array') {\n      return (\n        <div key={`array-field-${field.name}`} className=\"space-y-4\">\n          <ArrayFieldComponent form={form} field={field} />\n        </div>\n      );\n    }\n\n    return (\n      <FormField\n        key={`form-field-${field.name}`}\n        control={form.control}\n        name={field.name as any}\n        render={({ field: formField }) => (\n          <FormItem>\n            <FormLabel>\n              {field.label}\n              {field.validation?.required && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n            </FormLabel>\n            <FormControl>\n              {field.type === 'select' ? (\n                <Select\n                  value={formField.value?.toString() || ''}\n                  onValueChange={(value) => {\n                    formField.onChange(value);\n                    if (field.onChange) {\n                      field.onChange(value);\n                    }\n                  }}\n                  disabled={field.disabled || field.readOnly}\n                >\n                  <SelectTrigger className={field.readOnly ? 'bg-muted' : ''}>\n                    <SelectValue placeholder={field.placeholder} />\n                  </SelectTrigger>\n                  <SelectContent>\n                    {field.options?.map((option) => (\n                      <SelectItem\n                        key={`${field.name}-option-${option.value}`}\n                        value={option.value}\n                      >\n                        {option.label}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              ) : (\n                <Input\n                  type={field.type}\n                  placeholder={field.placeholder}\n                  className={field.readOnly ? 'bg-muted' : ''}\n                  readOnly={field.readOnly}\n                  disabled={field.disabled}\n                  {...formField}\n                  onChange={(e) => {\n                    const value = field.type === 'number'\n                      ? e.target.value === '' ? null : Number(e.target.value)\n                      : e.target.value;\n                    formField.onChange(value);\n                    if (field.onChange) {\n                      field.onChange(value);\n                    }\n                  }}\n                />\n              )}\n            </FormControl>\n            {field.description && (\n              <FormDescription>{field.description}</FormDescription>\n            )}\n            {field.readOnly && field.readOnlyMessage && (\n              <Alert variant=\"destructive\" className=\"mt-2\">\n                <AlertCircle className=\"h-4 w-4\" />\n                <AlertDescription>\n                  {field.readOnlyMessage}\n                </AlertDescription>\n              </Alert>\n            )}\n            <FormMessage />\n          </FormItem>\n        )}\n      />\n    );\n  };\n\n  if (initialLoading) {\n    return (\n      <div className=\"flex justify-center items-center min-h-[200px]\">\n        <div className=\"w-8 h-8 border-t-2 border-b-2 border-primary rounded-full animate-spin\" />\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"pt-4 space-y-4\">\n      <h1 className=\"text-2xl font-semibold\">{title}</h1>\n      <Card>\n        <CardContent className=\"pt-6\">\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n              {fields.map((field) => renderFormField(field))}\n            </form>\n          </Form>\n        </CardContent>\n      </Card>\n\n      <div className=\"flex justify-end space-x-2\">\n        <Button\n          variant=\"outline\"\n          onClick={onCancel}\n          type=\"button\"\n          className=\"min-w-[100px]\"\n        >\n          {t('cancel')}\n        </Button>\n        <Button\n          onClick={form.handleSubmit(onSubmit)}\n          disabled={loading}\n          className=\"min-w-[100px]\"\n        >\n          {loading ? (\n            <div className=\"flex items-center justify-center\">\n              <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n              {t('updating')}\n            </div>\n          ) : (\n            t('update')\n          )}\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default ResourceEdit;",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-edit/messages/en.json",
      "content": "{\n  \"component\": {\n    \"resource-edit\": {\n      \"add\": \"Add\",\n      \"select\": \"Select {label}\",\n      \"successmessage\": \"Resource updated successfully\",\n      \"errormessage\": \"An error occurred while updating the resource\",\n      \"error\": \"Error\",\n      \"fetcherror\": \"Failed to fetch resource data\",\n      \"updated\": \"{resourceName} has been updated\",\n      \"canceledit\": \"Edit canceled\",\n      \"cancel\": \"Cancel\",\n      \"updating\": \"Updating...\",\n      \"update\": \"Update\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-edit/en.json"
    },
    {
      "path": "registry/new-york/blocks/resource-edit/messages/ja.json",
      "content": "{\n  \"component\": {\n    \"resource-edit\": {\n      \"add\": \"追加\",\n      \"select\": \"{label}を選択\",\n      \"successmessage\": \"リソースが正常に更新されました\",\n      \"errormessage\": \"リソースの更新中にエラーが発生しました\",\n      \"error\": \"エラー\",\n      \"fetcherror\": \"リソースの取得中にエラーが発生しました\",\n      \"updated\": \"{resourceName}が更新されました\",\n      \"canceledit\": \"編集をキャンセルしました\",\n      \"cancel\": \"キャンセル\",\n      \"updating\": \"更新中...\",\n      \"update\": \"更新\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-edit/ja.json"
    }
  ]
}