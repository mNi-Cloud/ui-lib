{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "resource-form",
  "type": "registry:component",
  "title": "Resource Form",
  "description": "A resource create/edit form component.",
  "dependencies": [
    "next-intl",
    "@hookform/resolvers",
    "react-hook-form",
    "sonner",
    "zod"
  ],
  "registryDependencies": [
    "form",
    "card",
    "input",
    "select",
    "button",
    "alert",
    "progress",
    "textarea",
    "sonner",
    "alert",
    "https://raw.github.com/mNi-Cloud/ui-lib/main/public/r/actions.json",
    "https://raw.github.com/mNi-Cloud/ui-lib/main/public/r/code-editor.json"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/resource-form/resource-form.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { useForm, UseFormReturn } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { toast } from 'sonner';\nimport { useTranslations } from 'next-intl';\nimport { Card, CardContent } from '@/registry/new-york/ui/card';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { Form } from '@/registry/new-york/ui/form';\nimport { Progress } from '@/registry/new-york/ui/progress';\nimport { Alert, AlertDescription } from '@/registry/new-york/ui/alert';\nimport { AlertCircle } from 'lucide-react';\nimport { CommonFieldDefinition, StepDefinition, FormValues } from './resource-form-utils';\nimport { generateSchema, generateDefaultValues } from './schema-generator';\nimport FieldRenderer from './field-renderer';\nimport CodeEditor from '@/registry/new-york/blocks/code-editor/code-editor';\nimport { createResource, updateResource, fetchResource } from '@/registry/new-york/blocks/actions/resource-actions';\n\nconst getValidator = () => {\n  return () => ({ \n    isValid: true,\n    error: undefined,\n    markers: [] as Array<{ message: string; line: number; column: number }>\n  });\n};\n\ninterface ExtendedFormProps extends UseFormReturn<FormValues, unknown, FormValues> {\n  _syntaxErrors?: Record<string, boolean>;\n}\n\nexport type ResourceFormProps = {\n  title: string;\n  resourceType: string;\n  fields: CommonFieldDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: FormValues) => Record<string, unknown>;\n  defaultValues?: Record<string, unknown>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\nexport type MultiStepResourceFormProps = {\n  title: string;\n  resourceType: string;\n  steps: StepDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: FormValues) => Record<string, unknown>;\n  defaultValues?: Record<string, unknown>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\nexport const ResourceForm: React.FC<ResourceFormProps> = ({\n  title,\n  resourceType,\n  fields,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  formatFormData,\n  defaultValues = {},\n  resourceId,\n  isEditMode = false\n}) => {\n  const router = useRouter();\n  const t = useTranslations('components.resource-form');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [syntaxError, setSyntaxError] = useState<string | null>(null);\n\n  const safeFields = Array.isArray(fields) ? fields : [];\n\n  const formSchema = generateSchema(safeFields, t, getValidator);\n\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: generateDefaultValues(safeFields, defaultValues),\n  }) as ExtendedFormProps;\n\n  const checkSyntaxErrors = (): boolean => {\n    if (form._syntaxErrors) {\n      const hasErrors = Object.entries(form._syntaxErrors).some(([, hasError]) => hasError === true);\n      if (hasErrors) {\n        setSyntaxError(t('syntax-error-message'));\n        return true;\n      }\n    }\n    \n    setSyntaxError(null);\n    return false;\n  };\n\n  useEffect(() => {\n    if (isEditMode && resourceId) {\n      const getResource = async () => {\n        try {\n          const data = await fetchResource(apiEndpoint, resourceId);\n          if (data) {\n            Object.entries(data).forEach(([key, value]) => {\n              try {\n                form.setValue(key, value, {\n                  shouldValidate: false,\n                  shouldDirty: false\n                });\n              } catch (error) {\n                console.warn(`Failed to set form value for key: ${key}`, error);\n              }\n            });\n          }\n        } catch (err) {\n          console.error('Failed to fetch resource:', err);\n          setError(t('fetch-error'));\n        }\n      };\n\n      getResource();\n    }\n  }, [isEditMode, resourceId, apiEndpoint, form, t]);\n\n  const onSubmit = async (data: z.infer<typeof formSchema>) => {\n    if (checkSyntaxErrors()) {\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const formattedData = formatFormData ? formatFormData(data as FormValues) : data;\n\n      let result;\n      if (isEditMode && resourceId) {\n        result = await updateResource(apiEndpoint, resourceId, {\n          type: resourceType,\n          data: formattedData,\n        });\n      } else {\n        result = await createResource(apiEndpoint, {\n          type: resourceType,\n          data: formattedData,\n        });\n      }\n\n      if (result) {\n        toast.success(\n          successMessage || (isEditMode ? t('updated-success') : t('created-success')), \n          { id: 'resource-action' }\n        );\n        router.push(redirectPath);\n      }\n    } catch (e) {\n      console.error('Form submission error:', e);\n      setError(errorMessage || (isEditMode ? t('updated-error') : t('created-error')));\n      toast.error(\n        errorMessage || (isEditMode ? t('updated-error') : t('created-error')), \n        { id: 'resource-action' }\n      );\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const onCancel = () => {\n    router.push(redirectPath);\n  };\n\n  return (\n    <Card>\n      <CardContent className=\"p-6\">\n        <div className=\"space-y-6\">\n          <div>\n            <h1 className=\"text-2xl font-semibold mb-2\">{title}</h1>\n          </div>\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n              {safeFields.map(field => (\n                <FieldRenderer \n                  key={`field-${field.name}`}\n                  field={field} \n                  form={form}\n                  translationNamespace=\"components.resource-form\"\n                  codeEditor={CodeEditor}\n                />\n              ))}\n              \n              {syntaxError && (\n                <Alert variant=\"destructive\" className=\"mt-4\">\n                  <AlertCircle className=\"h-4 w-4\" />\n                  <AlertDescription>\n                    {syntaxError}\n                  </AlertDescription>\n                </Alert>\n              )}\n              \n              {error && (\n                <Alert variant=\"destructive\" className=\"mt-4\">\n                  <AlertCircle className=\"h-4 w-4\" />\n                  <AlertDescription>\n                    {error}\n                  </AlertDescription>\n                </Alert>\n              )}\n              \n              <div className=\"flex justify-end gap-2\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={onCancel}\n                >\n                  {t('cancel')}\n                </Button>\n                <Button\n                  type=\"submit\"\n                  disabled={loading}\n                >\n                  {loading ? (\n                    <div className=\"flex items-center\">\n                      <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n                      {isEditMode ? t('updating') : t('creating')}\n                    </div>\n                  ) : (\n                    isEditMode ? t('update') : t('create')\n                  )}\n                </Button>\n              </div>\n            </form>\n          </Form>\n        </div>\n      </CardContent>\n    </Card>\n  );\n};\n\nexport const MultiStepResourceForm: React.FC<MultiStepResourceFormProps> = ({\n  title,\n  resourceType,\n  steps,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  formatFormData,\n  defaultValues = {},\n  resourceId,\n  isEditMode = false\n}) => {\n  const router = useRouter();\n  const t = useTranslations('components.resource-form');\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [allStepsData, setAllStepsData] = useState<Record<string, unknown>>({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [syntaxError, setSyntaxError] = useState<string | null>(null);\n\n  const currentStep = steps[currentStepIndex];\n  const safeFields = Array.isArray(currentStep.fields) ? currentStep.fields : [];\n\n  const formSchema = generateSchema(safeFields, t, getValidator);\n\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      ...generateDefaultValues(safeFields, {}),\n      ...(allStepsData[currentStep.id] || {}),\n      ...(defaultValues || {})\n    }\n  }) as ExtendedFormProps;\n\n  const checkSyntaxErrors = (): boolean => {\n    if (form._syntaxErrors) {\n      const hasErrors = Object.entries(form._syntaxErrors).some(([, hasError]) => hasError === true);\n      if (hasErrors) {\n        setSyntaxError(t('syntax-error-message'));\n        return true;\n      }\n    }\n    \n    setSyntaxError(null);\n    return false;\n  };\n\n  useEffect(() => {\n    if (isEditMode && resourceId && currentStepIndex === 0) {\n      const getResource = async () => {\n        try {\n          const data = await fetchResource(apiEndpoint, resourceId);\n          if (data) {\n            setAllStepsData(data);\n            Object.entries(data).forEach(([key, value]) => {\n              try {\n                form.setValue(key, value, {\n                  shouldValidate: false,\n                  shouldDirty: false\n                });\n              } catch (error) {\n                console.warn(`Failed to set form value for key: ${key}`, error);\n              }\n            });\n          }\n        } catch (error) {\n          console.error('Failed to fetch resource:', error);\n          setError(t('fetch-error'));\n        }\n      };\n\n      getResource();\n    }\n  }, [isEditMode, resourceId, apiEndpoint, form, currentStepIndex, t]);\n\n  const handleNextStep = async () => {\n    if (checkSyntaxErrors()) {\n      return;\n    }\n\n    const formData = form.getValues();\n\n    setAllStepsData(prev => ({\n      ...prev,\n      [currentStep.id]: formData\n    }));\n\n    if (currentStepIndex === steps.length - 1) {\n      const allFormData = {\n        ...allStepsData,\n        [currentStep.id]: formData\n      };\n      await handleSubmit(allFormData);\n    } else {\n      setCurrentStepIndex(prev => prev + 1);\n    }\n  };\n\n  const handlePrevStep = () => {\n    if (currentStepIndex > 0) {\n      const currentData = form.getValues();\n      setAllStepsData(prev => ({ ...prev, ...currentData }));\n      setCurrentStepIndex(prev => prev - 1);\n    }\n  };\n\n  const handleSubmit = async (data: Record<string, unknown>) => {\n    if (checkSyntaxErrors()) {\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const formattedData = formatFormData ? formatFormData(data as FormValues) : data;\n\n      let result;\n      if (isEditMode && resourceId) {\n        result = await updateResource(apiEndpoint, resourceId, {\n          type: resourceType,\n          data: formattedData,\n        });\n      } else {\n        result = await createResource(apiEndpoint, {\n          type: resourceType,\n          data: formattedData,\n        });\n      }\n\n      if (result) {\n        toast.success(\n          successMessage || (isEditMode ? t('updated-success') : t('created-success')), \n          { id: 'resource-action' }\n        );\n        router.push(redirectPath);\n      }\n    } catch (e) {\n      console.error('Form submission error:', e);\n      setError(errorMessage || (isEditMode ? t('updated-error') : t('created-error')));\n      toast.error(\n        errorMessage || (isEditMode ? t('updated-error') : t('created-error')), \n        { id: 'resource-action' }\n      );\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const onCancel = () => {\n    router.push(redirectPath);\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"mb-4\">\n        <h1 className=\"text-2xl font-semibold\">{title}</h1>\n        {steps.length > 1 && (\n          <div className=\"mt-4\">\n            <div className=\"flex justify-between mb-1\">\n              <span className=\"text-sm\">{t('step')} {currentStepIndex + 1} / {steps.length}</span>\n              <span className=\"text-sm\">{currentStep.title}</span>\n            </div>\n            <Progress value={((currentStepIndex + 1) / steps.length) * 100} className=\"h-2\" />\n          </div>\n        )}\n      </div>\n\n      <Card>\n        <CardContent className=\"p-6\">\n          {currentStep.description && (\n            <p className=\"text-muted-foreground mb-6\">{currentStep.description}</p>\n          )}\n\n          <Form {...form}>\n            <form className=\"space-y-6\">\n              {safeFields.map(field => (\n                <FieldRenderer\n                  key={`field-${field.name}`}\n                  field={field}\n                  form={form}\n                  translationNamespace=\"components.resource-form\"\n                  codeEditor={CodeEditor}\n                />\n              ))}\n            </form>\n          </Form>\n        </CardContent>\n      </Card>\n\n      {error && (\n        <Alert variant=\"destructive\">\n          <AlertCircle className=\"h-4 w-4\" />\n          <AlertDescription>\n            {error}\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {syntaxError && (\n        <Alert variant=\"destructive\">\n          <AlertCircle className=\"h-4 w-4\" />\n          <AlertDescription>\n            {syntaxError}\n          </AlertDescription>\n        </Alert>\n      )}\n\n      <div className=\"flex justify-end gap-4\">\n        {currentStepIndex > 0 && (\n          <Button\n            type=\"button\"\n            variant=\"outline\"\n            onClick={handlePrevStep}\n            disabled={loading}\n          >\n            {t('prev')}\n          </Button>\n        )}\n        <Button\n          type=\"button\"\n          onClick={onCancel}\n          variant=\"outline\"\n          disabled={loading}\n        >\n          {t('cancel')}\n        </Button>\n        <Button\n          type=\"button\"\n          onClick={handleNextStep}\n          disabled={loading}\n        >\n          {loading ? (\n            <div className=\"flex items-center\">\n              <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n              {currentStepIndex === steps.length - 1 ? \n                (isEditMode ? t('updating') : t('creating')) :\n                t('next')\n              }\n            </div>\n          ) : (\n            currentStepIndex === steps.length - 1 ? \n              (isEditMode ? t('update') : t('create')) :\n              t('next')\n          )}\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default ResourceForm;",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/field-renderer.tsx",
      "content": "'use client';\n\nimport React from 'react';\nimport { useFieldArray, UseFormReturn, Path, PathValue, ArrayPath } from 'react-hook-form';\nimport { Input } from '@/registry/new-york/ui/input';\nimport { Textarea } from '@/registry/new-york/ui/textarea';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/registry/new-york/ui/select';\nimport {\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n  FormDescription,\n} from '@/registry/new-york/ui/form';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { X } from 'lucide-react';\nimport { useTranslations } from 'next-intl';\nimport { \n  CommonFieldDefinition,\n  FormValues\n} from '@/registry/new-york/blocks/resource-form/resource-form-utils';\nimport { SupportedLanguage } from '@/registry/new-york/blocks/code-editor/code-editor';\n\ninterface ExtendedFormProps extends UseFormReturn<FormValues, unknown, FormValues> {\n  _syntaxErrors?: Record<string, boolean>;\n}\n\nconst getValidator = () => {\n  return () => ({ isValid: true });\n};\n\ntype FieldRendererProps = {\n  field: CommonFieldDefinition;\n  form: ExtendedFormProps;\n  fieldNamePrefix?: string;\n  translationNamespace?: string;\n  codeEditor?: React.ComponentType<{\n    value: string;\n    onChange: (value: string) => void;\n    language?: SupportedLanguage;\n    height?: string;\n    placeholder?: string;\n    disabled?: boolean;\n    readOnly?: boolean;\n    showValidation?: boolean;\n    validator?: (content: string) => { isValid: boolean; error?: string };\n    theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light';\n    onValidationChange?: (hasErrors: boolean) => void;\n  }>;\n};\n\nexport const FieldRenderer: React.FC<FieldRendererProps> = ({\n  field,\n  form,\n  fieldNamePrefix = '',\n  translationNamespace = 'components.resource-create',\n  codeEditor: CodeEditor\n}) => {\n  const t = useTranslations(translationNamespace);\n  const fieldName = fieldNamePrefix ? `${fieldNamePrefix}.${field.name}` : field.name;\n\n  const renderReadOnlyMessage = () => {\n    if (field.readOnly && field.readOnlyMessage) {\n      return (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      );\n    }\n    return null;\n  };\n\n  if (field.type === 'custom' && field.render) {\n    return (\n      <div key={`form-field-${fieldName}`}>\n        {field.render({ \n          values: form.getValues(), \n          form \n        })}\n      </div>\n    );\n  }\n\n  if (field.type === 'unit-input') {\n    return (\n      <div key={`form-field-${fieldName}`} className=\"space-y-2\">\n        <div className=\"space-y-1\">\n          <FormLabel className=\"text-sm font-medium\">\n            {field.label}\n            {field.validation?.required && (\n              <span className=\"text-destructive ml-1\">*</span>\n            )}\n          </FormLabel>\n          {field.description && (\n            <FormDescription className=\"text-xs\">\n              {field.description}\n            </FormDescription>\n          )}\n          {renderReadOnlyMessage()}\n        </div>\n\n        <div className=\"flex flex-col md:flex-row gap-2 w-full\">\n          <div className=\"flex-grow\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Value` as Path<FormValues>}\n              render={({ field: formField }) => (\n                <FormControl>\n                  <Input\n                    type=\"number\"\n                    placeholder={field.placeholder}\n                    className={field.readOnly ? 'bg-muted' : 'h-10'}\n                    value={formField.value as string}\n                    onChange={(e) => {\n                      formField.onChange(e);\n                      const unit = form.getValues(`${fieldName}Unit` as Path<FormValues>) as string || '';\n                      form.setValue(fieldName as Path<FormValues>, `${e.target.value}${unit}` as PathValue<FormValues, Path<FormValues>>);\n                    }}\n                    readOnly={field.readOnly}\n                  />\n                </FormControl>\n              )}\n            />\n          </div>\n\n          <div className=\"w-full md:w-[160px]\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Unit` as Path<FormValues>}\n              render={({ field: formField }) => (\n                <Select\n                  value={formField.value as string}\n                  defaultValue={field.defaultUnit}\n                  onValueChange={(value) => {\n                    formField.onChange(value);\n                    const numValue = form.getValues(`${fieldName}Value` as Path<FormValues>) as string || '';\n                    form.setValue(fieldName as Path<FormValues>, `${numValue}${value}` as PathValue<FormValues, Path<FormValues>>);\n                  }}\n                  disabled={field.disabled || field.readOnly}\n                >\n                  <FormControl>\n                    <SelectTrigger className={field.readOnly ? 'bg-muted h-10' : 'h-10'}>\n                      <SelectValue />\n                    </SelectTrigger>\n                  </FormControl>\n                  <SelectContent>\n                    {field.units?.map((unit) => (\n                      <SelectItem\n                        key={`${fieldName}-unit-${unit.value}`}\n                        value={unit.value}\n                      >\n                        {unit.label}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              )}\n            />\n          </div>\n        </div>\n        <FormMessage className=\"text-xs\" />\n      </div>\n    );\n  }\n\n  if (field.type === 'code' && CodeEditor) {\n    const language = (field.language || 'plaintext') as SupportedLanguage;\n    const validator = getValidator();\n\n    return (\n      <FormField\n        key={`form-field-${fieldName}`}\n        control={form.control}\n        name={fieldName as Path<FormValues>}\n        render={({ field: formField }) => (\n          <FormItem className=\"space-y-2\">\n            <div className=\"space-y-1\">\n              <FormLabel className=\"text-sm font-medium\">\n                {field.label}\n                {field.validation?.required && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n              </FormLabel>\n              {field.description && (\n                <FormDescription className=\"text-xs\">\n                  {field.description}\n                </FormDescription>\n              )}\n              {renderReadOnlyMessage()}\n            </div>\n            <FormControl>\n              <CodeEditor\n                value={formField.value as string}\n                onChange={(value: string) => {\n                  if (!field.readOnly) {\n                    formField.onChange(value);\n                    if (field.onChange) {\n                      field.onChange(value);\n                    }\n                  }\n                }}\n                language={language}\n                readOnly={field.readOnly}\n                height={field.height || '300px'}\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                showValidation={field.validation?.codeValidation !== false}\n                validator={validator}\n                theme={field.theme || 'vs-dark'}\n                onValidationChange={(hasErrors) => {\n                  if (form._syntaxErrors) {\n                    form._syntaxErrors[fieldName] = hasErrors;\n                  }\n                }}\n              />\n            </FormControl>\n            <FormMessage className=\"text-xs\" />\n          </FormItem>\n        )}\n      />\n    );\n  }\n\n  if (field.type === 'array') {\n    return <ArrayFieldRenderer field={field} form={form} fieldName={fieldName} t={t} />;\n  }\n\n  return (\n    <FormField\n      key={`form-field-${fieldName}`}\n      control={form.control}\n      name={fieldName as Path<FormValues>}\n      render={({ field: formField }) => {\n        const formValue = typeof formField.value === 'undefined' ? '' : formField.value;\n        \n        const handleSelectChange = (value: string) => {\n          formField.onChange(value);\n          if (field.onChange) {\n            field.onChange(value);\n          }\n        };\n        \n        return (\n          <FormItem>\n            <FormLabel className=\"text-sm font-medium\">\n              {field.label}\n              {field.validation?.required && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n            </FormLabel>\n            {field.description && (\n              <FormDescription className=\"text-xs\">\n                {field.description}\n              </FormDescription>\n            )}\n            {renderReadOnlyMessage()}\n            <FormControl>\n              {field.type === 'select' ? (\n                <div>\n                  <SelectTrigger \n                    className={field.readOnly ? 'bg-muted' : ''}\n                    onClick={(e) => {\n                      if (field.readOnly || field.disabled) {\n                        e.preventDefault();\n                      }\n                    }}\n                  >\n                    <SelectValue placeholder={field.placeholder}>\n                      {formValue ? String(formValue) : (field.placeholder || '')}\n                    </SelectValue>\n                  </SelectTrigger>\n                  {!(field.readOnly || field.disabled) && (\n                    <SelectContent>\n                      {field.options?.map((option) => (\n                        <SelectItem\n                          key={`${fieldName}-option-${option.value}`}\n                          value={option.value}\n                          onClick={() => handleSelectChange(option.value)}\n                        >\n                          {option.label}\n                        </SelectItem>\n                      ))}\n                    </SelectContent>\n                  )}\n                </div>\n              ) : field.type === 'textarea' ? (\n                <Textarea\n                  placeholder={field.placeholder}\n                  className={field.readOnly ? 'bg-muted' : ''}\n                  value={String(formValue)}\n                  onChange={(e) => {\n                    formField.onChange(e);\n                    if (field.onChange) {\n                      field.onChange(e.target.value);\n                    }\n                  }}\n                  disabled={field.disabled}\n                  readOnly={field.readOnly}\n                  rows={4}\n                />\n              ) : (\n                <Input\n                  type={field.type === 'number' ? 'number' : field.type === 'email' ? 'email' : field.type === 'password' ? 'password' : 'text'}\n                  placeholder={field.placeholder}\n                  className={field.readOnly ? 'bg-muted' : ''}\n                  value={String(formValue)}\n                  onChange={(e) => {\n                    formField.onChange(e);\n                    if (field.onChange) {\n                      field.onChange(e.target.value);\n                    }\n                  }}\n                  disabled={field.disabled}\n                  readOnly={field.readOnly}\n                />\n              )}\n            </FormControl>\n            <FormMessage className=\"text-xs\" />\n          </FormItem>\n        );\n      }}\n    />\n  );\n};\n\ninterface ArrayFieldRendererProps {\n  field: CommonFieldDefinition;\n  form: ExtendedFormProps;\n  fieldName: string;\n  t: (key: string, params?: Record<string, string | number>) => string;\n}\n\ntype ArrayFormValues = FormValues & {\n  [key: string]: unknown | unknown[];\n};\n\nconst ArrayFieldRenderer: React.FC<ArrayFieldRendererProps> = ({ field, form, fieldName, t }) => {\n  const { fields, append, remove } = useFieldArray({\n    control: form.control,\n    name: fieldName as ArrayPath<ArrayFormValues>,\n  });\n\n  const addNewItem = () => {\n    if (field.readOnly) return;\n\n    if (field.itemType === 'object' && field.fields) {\n      const newItem: Record<string, string | number | null> = {};\n      field.fields.forEach((fieldItem) => {\n        newItem[fieldItem.name] = fieldItem.type === 'number' ? null : '';\n      });\n      \n      append(newItem as unknown as Record<string, unknown>);\n    } else {\n      append('' as unknown as string);\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <FormLabel>\n          {field.label}\n          {field.validation?.required && (\n            <span className=\"text-destructive ml-1\">*</span>\n          )}\n        </FormLabel>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={addNewItem}\n          disabled={field.readOnly}\n        >\n          {t('add')}\n        </Button>\n      </div>\n      {field.description && (\n        <FormDescription className=\"text-xs\">\n          {field.description}\n        </FormDescription>\n      )}\n      {field.readOnly && field.readOnlyMessage && (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      )}\n\n      {fields.map((arrayField, index) => (\n        <div key={arrayField.id} className=\"relative\">\n          {field.itemType === 'object' ? (\n            <div className=\"flex gap-4 items-start\">\n              {field.fields?.map((subField) => (\n                <FormField\n                  key={`${arrayField.id}-${subField.name}`}\n                  control={form.control}\n                  name={`${fieldName}.${index}.${subField.name}` as Path<ArrayFormValues>}\n                  render={({ field: formField }) => {\n                    const fieldValue = formField.value === undefined ? '' : formField.value;\n                    \n                    return (\n                      <FormItem className=\"flex-1\">\n                        <FormLabel>{subField.label}</FormLabel>\n                        <FormControl>\n                          {subField.type === 'select' ? (\n                            <Select\n                              value={fieldValue !== null ? String(fieldValue) : ''}\n                              onValueChange={(value) => {\n                                if (!field.readOnly) {\n                                  formField.onChange(value);\n                                  if (subField.onChange) {\n                                    subField.onChange(value);\n                                  }\n                                }\n                              }}\n                              disabled={subField.disabled || field.readOnly}\n                            >\n                              <SelectTrigger className={field.readOnly ? 'bg-muted' : ''}>\n                                <SelectValue\n                                  placeholder={subField.placeholder || t('select', { label: subField.label })}\n                                />\n                              </SelectTrigger>\n                              <SelectContent>\n                                {subField.options?.map((option) => (\n                                  <SelectItem\n                                    key={`${subField.name}-${index}-option-${option.value}`}\n                                    value={option.value}\n                                  >\n                                    {option.label}\n                                  </SelectItem>\n                                ))}\n                              </SelectContent>\n                            </Select>\n                          ) : (\n                            <Input\n                              type={subField.type}\n                              placeholder={subField.placeholder}\n                              className={field.readOnly ? 'bg-muted' : ''}\n                              disabled={subField.disabled || field.readOnly}\n                              readOnly={field.readOnly}\n                              value={fieldValue !== null ? String(fieldValue) : ''}\n                              onChange={(e) => {\n                                if (!field.readOnly) {\n                                  const value = subField.type === 'number'\n                                    ? e.target.value === '' ? null : Number(e.target.value)\n                                    : e.target.value;\n                                  \n                                  formField.onChange(value);\n                                  \n                                  if (subField.onChange && value !== null) {\n                                    subField.onChange(value as string | number);\n                                  }\n                                }\n                              }}\n                            />\n                          )}\n                        </FormControl>\n                        <FormMessage />\n                        {subField.description && (\n                          <FormDescription>{subField.description}</FormDescription>\n                        )}\n                      </FormItem>\n                    );\n                  }}\n                />\n              ))}\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"mt-8\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          ) : (\n            <div className=\"flex gap-2\">\n              <FormField\n                control={form.control}\n                name={`${fieldName}.${index}` as Path<ArrayFormValues>}\n                render={({ field: formField }) => (\n                  <FormItem className=\"flex-1\">\n                    <FormControl>\n                      <Input\n                        className={field.readOnly ? 'bg-muted' : ''}\n                        readOnly={field.readOnly}\n                        disabled={field.readOnly}\n                        value={String(formField.value || '')}\n                        onChange={(e) => {\n                          if (!field.readOnly) {\n                            formField.onChange(e);\n                          }\n                        }}\n                        onBlur={formField.onBlur}\n                        name={formField.name}\n                        ref={formField.ref}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default FieldRenderer; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/resource-form-utils.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\nimport { SupportedLanguage } from '@/registry/new-york/blocks/code-editor/code-editor';\nimport { UseFormReturn } from 'react-hook-form';\n\nexport type SelectOption = {\n  value: string;\n  label: string;\n};\n\nexport type UnitOption = SelectOption;\n\nexport type ValidationPattern = {\n  value: string;\n  flags?: string;\n  message: string;\n};\n\nexport type BaseFieldValidation = {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: ValidationPattern;\n  codeValidation?: boolean;\n};\n\nexport type FormValues = Record<string, unknown>;\n\nexport type BaseFieldDefinition = {\n  name: string;\n  label: string;\n  placeholder?: string;\n  description?: string;\n  validation?: BaseFieldValidation;\n  disabled?: boolean;\n  onChange?: (value: string | number | readonly string[] | boolean) => void;\n  defaultValue?: string | number;\n  readOnly?: boolean;\n  readOnlyMessage?: string;\n};\n\nexport type CommonFieldType = \n  'text' | 'number' | 'email' | 'password' | 'select' | \n  'array' | 'unit-input' | 'textarea' | 'yaml' | 'custom' | 'code';\n\nexport type CommonFieldObjectDefinition = Omit<BaseFieldDefinition, 'onChange'> & {\n  type: 'text' | 'number' | 'email' | 'password' | 'select';\n  options?: SelectOption[];\n  onChange?: (value: string | number | readonly string[]) => void;\n};\n\nexport type RenderFunctionProps = { \n  values: FormValues; \n  form: UseFormReturn<FormValues, unknown, FormValues>\n};\n\nexport type CommonFieldDefinition = BaseFieldDefinition & {\n  type: CommonFieldType;\n  options?: SelectOption[];\n  units?: UnitOption[];\n  defaultUnit?: string;\n  itemType?: 'text' | 'object';\n  fields?: CommonFieldObjectDefinition[]; \n  render?: (props: RenderFunctionProps) => React.ReactNode; \n  language?: SupportedLanguage;     \n  height?: string;                  \n  theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light';\n};\n\nexport type StepDefinition = {\n  id: string;\n  title: string;\n  description?: string;\n  fields: CommonFieldDefinition[];\n};\n\nexport const generateFieldSchema = (\n  field: {\n    name: string;\n    label: string;\n    type?: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, string | number | Date>) => string\n) => {\n  const baseSchema = z.string();\n  \n  if (!field.validation) {\n    return baseSchema;\n  }\n  \n  const withValidation = applyValidationRules(baseSchema, field, t);\n  \n  return withValidation;\n};\n\nfunction applyValidationRules(\n  schema: z.ZodString,\n  field: {\n    name: string;\n    label: string;\n    type?: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, string | number | Date>) => string\n): z.ZodString {\n  let result = schema;\n  \n  if (field.validation?.required) {\n    result = result.min(1, t('need', { label: field.label }));\n  }\n  \n  if (field.validation?.maxLength) {\n    result = result.max(\n      field.validation.maxLength,\n      t('textlesser', { label: field.label, maxLength: field.validation.maxLength })\n    );\n  }\n  \n  if (field.validation?.pattern) {\n    const regex = new RegExp(\n      field.validation.pattern.value,\n      field.validation.pattern.flags\n    );\n    result = result.regex(regex, field.validation.pattern.message);\n  }\n  \n  return result;\n}\n\nexport const addNumberValidation = (\n  fieldSchema: z.ZodString,\n  field: {\n    label: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, string | number | Date>) => string\n) => {\n  return fieldSchema.superRefine((val, ctx) => {\n    if (val === '') return;\n\n    const num = Number(val);\n    if (isNaN(num)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('number'),\n      });\n      return;\n    }\n\n    if (field.validation?.min !== undefined && num < field.validation.min) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('greater', { label: field.label, min: field.validation.min }),\n      });\n    }\n\n    if (field.validation?.max !== undefined && num > field.validation.max) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('lesser', { label: field.label, max: field.validation.max }),\n      });\n    }\n  });\n};\n\nexport interface ValidationResult {\n  isValid: boolean;\n  error?: string;\n  markers?: Array<{ message: string; line: number; column: number }>;\n}\n\nexport type ValidatorFunction = (content: string) => ValidationResult;\n\nexport const generateFieldSchemaByType = (\n  field: CommonFieldDefinition,\n  t: (key: string, params?: Record<string, string | number | Date>) => string,\n  getValidatorFn?: (language: SupportedLanguage) => ValidatorFunction\n) => {\n  const fieldSchema = generateFieldSchema(field, t);\n\n  if (field.type === 'number') {\n    return addNumberValidation(fieldSchema, field, t);\n  } \n  \n  if (field.type === 'code' && field.validation?.codeValidation && getValidatorFn && field.language) {\n    const validator = getValidatorFn(field.language);\n    if (validator) {\n      return fieldSchema.superRefine((val, ctx) => {\n        if (!val) return;\n        \n        const result = validator(val);\n        if (!result.isValid) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: result.error || 'Invalid code format',\n          });\n        }\n      });\n    }\n  }\n\n  return fieldSchema;\n};\n\nexport const processNestedSchema = (obj: Record<string, unknown>): Record<string, z.ZodTypeAny> => {\n  const processed: Record<string, z.ZodTypeAny> = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (value instanceof z.ZodType) {\n      processed[key] = value;\n    } else if (typeof value === 'object' && value !== null) {\n      const nestedSchema = processNestedSchema(value as Record<string, unknown>);\n      processed[key] = z.object(nestedSchema);\n    }\n  }\n\n  return processed;\n};\n\nexport const handleNestedField = (\n  obj: Record<string, unknown>,\n  paths: string[],\n  schema: z.ZodType,\n  fieldType?: string,\n  fieldConfig?: Record<string, unknown>\n) => {\n  const [first, ...rest] = paths;\n  if (!first) return;\n\n  if (rest.length === 0) {\n    if (fieldType === 'array') {\n      if (fieldConfig?.itemType === 'object' && fieldConfig?.fields) {\n        const objectSchema: Record<string, z.ZodType> = {};\n        (fieldConfig.fields as Array<{name: string}>).forEach((subField) => {\n          objectSchema[subField.name] = z.string();\n        });\n        obj[first] = z.array(z.object(objectSchema));\n      } else {\n        obj[first] = z.array(z.string());\n      }\n    } else {\n      obj[first] = schema;\n    }\n  } else {\n    obj[first] = obj[first] || {};\n    handleNestedField(obj[first] as Record<string, unknown>, rest, schema, fieldType, fieldConfig);\n  }\n};\n\nexport const setNestedValue = (obj: Record<string, unknown>, path: string[], value: unknown): Record<string, unknown> => {\n  if (path.length === 0) return obj;\n\n  let current = obj;\n  const lastIndex = path.length - 1;\n\n  for (let i = 0; i < lastIndex; i++) {\n    const key = path[i];\n    if (key) {\n      if (!current[key] || typeof current[key] !== 'object' || current[key] === null) {\n        current[key] = {};\n      }\n      current = current[key] as Record<string, unknown>;\n    }\n  }\n\n  const lastKey = path[lastIndex];\n  if (lastKey) {\n    current[lastKey] = value;\n  }\n\n  return obj;\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/schema-generator.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\nimport { \n  CommonFieldDefinition, \n  generateFieldSchemaByType, \n  handleNestedField,\n  processNestedSchema\n} from './resource-form-utils';\nimport { SupportedLanguage } from '@/registry/new-york/blocks/code-editor/code-editor';\n\nexport const generateSchema = (\n  fields: CommonFieldDefinition[],\n  t: (key: string, params?: Record<string, string | number | Date>) => string,\n  codeValidator?: (language: SupportedLanguage) => (content: string) => { \n    isValid: boolean; \n    error?: string; \n    markers?: Array<{ message: string; line: number; column: number }> \n  }\n) => {\n  const schemaObject: Record<string, z.ZodType> = {};\n\n  const getValidatorFn = codeValidator;\n\n  fields.forEach(field => {\n    if (field.type === 'unit-input') {\n      const valueSchema = generateFieldSchemaByType(field, t, getValidatorFn);\n      const unitSchema = z.string().min(1, t('unit'));\n\n      schemaObject[`${field.name}Value`] = valueSchema;\n      schemaObject[`${field.name}Unit`] = unitSchema;\n    } else {\n      const fieldSchema = generateFieldSchemaByType(field, t, getValidatorFn);\n\n      const fieldPath = field.name.split('.');\n      if (fieldPath.length > 1) {\n        handleNestedField(schemaObject, fieldPath, fieldSchema, field.type, field);\n      } else {\n        if (field.type === 'array') {\n          if (field.itemType === 'object' && field.fields) {\n            const objectSchema: Record<string, z.ZodType> = {};\n            field.fields.forEach(subField => {\n              objectSchema[subField.name] = z.string();\n            });\n            schemaObject[field.name] = z.array(z.object(objectSchema));\n          } else {\n            schemaObject[field.name] = z.array(z.string());\n          }\n        } else {\n          schemaObject[field.name] = fieldSchema;\n        }\n      }\n    }\n  });\n\n  return z.object(processNestedSchema(schemaObject));\n};\n\nexport const generateDefaultValues = (\n  fields: CommonFieldDefinition[],\n  existingValues: Record<string, unknown> = {}\n): Record<string, unknown> => {\n  return fields.reduce((acc: Record<string, unknown>, field) => {\n    if (field.type === 'unit-input') {\n      const defaultUnit = field.defaultUnit || field.units?.[0]?.value || '';\n      acc[`${field.name}Value`] = field.defaultValue?.toString() || '';\n      acc[`${field.name}Unit`] = defaultUnit;\n    } else if (field.type === 'array') {\n      acc[field.name] = existingValues[field.name] || [];\n    } else {\n      acc[field.name] = field.defaultValue?.toString() || existingValues[field.name] || '';\n    }\n    return acc;\n  }, {});\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/en.json",
      "content": "{\n  \"components\": {\n    \"resource-form\": {\n      \"created-success\": \"Resource created successfully\",\n      \"updated-success\": \"Resource updated successfully\",\n      \"created-error\": \"Error creating resource\",\n      \"updated-error\": \"Error updating resource\",\n      \"fetch-error\": \"Failed to fetch resource\",\n      \"cancel\": \"Cancel\",\n      \"creating\": \"Creating...\",\n      \"updating\": \"Updating...\",\n      \"create\": \"Create\",\n      \"update\": \"Update\",\n      \"prev\": \"Previous\",\n      \"next\": \"Next\",\n      \"step\": \"Step\",\n      \"need\": \"{label} is required\",\n      \"textlesser\": \"{label} must be less than {maxLength} characters\",\n      \"number\": \"Must be a number\",\n      \"greater\": \"{label} must be greater than or equal to {min}\",\n      \"lesser\": \"{label} must be less than or equal to {max}\",\n      \"select\": \"Select {label}\",\n      \"add\": \"Add\",\n      \"unit\": \"Please select a unit\",\n      \"error\": \"An error occurred\",\n      \"loading\": \"Loading resource data...\",\n      \"syntax-error-message\": \"There are syntax errors. Please fix them before submitting.\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/en.json"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/ja.json",
      "content": "{\n  \"components\": {\n    \"resource-form\": {\n      \"created-success\": \"リソースが作成されました\",\n      \"updated-success\": \"リソースが更新されました\",\n      \"created-error\": \"リソースの作成中にエラーが発生しました\",\n      \"updated-error\": \"リソースの更新中にエラーが発生しました\",\n      \"fetch-error\": \"リソースの取得に失敗しました\",\n      \"cancel\": \"キャンセル\",\n      \"creating\": \"作成中...\",\n      \"updating\": \"更新中...\",\n      \"create\": \"作成\",\n      \"update\": \"更新\",\n      \"prev\": \"前へ\",\n      \"next\": \"次へ\",\n      \"step\": \"ステップ\",\n      \"need\": \"{label}は必須項目です\",\n      \"textlesser\": \"{label}は{maxLength}文字以内で入力してください\",\n      \"number\": \"数値を入力してください\",\n      \"greater\": \"{label}は{min}以上の値を入力してください\",\n      \"lesser\": \"{label}は{max}以下の値を入力してください\",\n      \"select\": \"{label}を選択\",\n      \"add\": \"追加\",\n      \"unit\": \"単位を選択してください\",\n      \"error\": \"エラーが発生しました\",\n      \"loading\": \"リソースデータを読み込み中...\",\n      \"syntax-error-message\": \"構文エラーがあります。エラーを修正してから送信してください。\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/ja.json"
    }
  ]
}