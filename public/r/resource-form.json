{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "resource-form",
  "type": "registry:component",
  "title": "Resource Form",
  "description": "A resource create/edit form component.",
  "dependencies": [
    "next-intl",
    "@hookform/resolvers",
    "react-hook-form",
    "sonner",
    "zod",
    "@monaco-editor/react"
  ],
  "registryDependencies": [
    "form",
    "card",
    "input",
    "select",
    "button",
    "alert",
    "progress",
    "textarea",
    "sonner",
    "alert",
    "https://raw.github.com/mNi-Cloud/ui-lib/main/public/r/actions.json"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/resource-form/resource-form.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { toast } from 'sonner';\nimport { useTranslations } from 'next-intl';\nimport { Card, CardContent } from '@/registry/new-york/ui/card';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { Form } from '@/registry/new-york/ui/form';\nimport { Progress } from '@/registry/new-york/ui/progress';\nimport { Alert, AlertDescription } from '@/registry/new-york/ui/alert';\nimport { AlertCircle } from 'lucide-react';\nimport { CommonFieldDefinition, StepDefinition } from './resource-form-utils';\nimport { generateSchema, generateDefaultValues } from './schema-generator';\nimport FieldRenderer from './field-renderer';\nimport CodeEditor from './code-editor';\nimport { getValidator } from './code-utils';\nimport { createResource, updateResource, fetchResource } from '@/registry/new-york/blocks/actions/resource-actions';\n\n// 単一ステップフォーム用の型定義\nexport type ResourceFormProps = {\n  title: string;\n  resourceType: string;\n  fields: CommonFieldDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: any) => any;\n  defaultValues?: Record<string, any>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\n// 複数ステップフォーム用の型定義\nexport type MultiStepResourceFormProps = {\n  title: string;\n  resourceType: string;\n  steps: StepDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: any) => any;\n  defaultValues?: Record<string, any>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\n/**\n * リソース作成・編集フォーム\n */\nexport const ResourceForm: React.FC<ResourceFormProps> = ({\n  title,\n  resourceType,\n  fields,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  formatFormData,\n  defaultValues = {},\n  resourceId,\n  isEditMode = false\n}) => {\n  const router = useRouter();\n  const t = useTranslations('components.resource-form');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // 安全にフィールドを処理\n  const safeFields = Array.isArray(fields) ? fields : [];\n\n  // フォームスキーマの生成\n  const formSchema = generateSchema(safeFields, t, getValidator);\n\n  // react-hook-formの設定\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: generateDefaultValues(safeFields, defaultValues),\n  });\n\n  // リソースの取得（編集モードの場合）\n  useEffect(() => {\n    if (isEditMode && resourceId) {\n      const getResource = async () => {\n        try {\n          const data = await fetchResource(apiEndpoint, resourceId);\n          if (data) {\n            // データを各フィールドにセット\n            Object.entries(data).forEach(([key, value]) => {\n              // ネストされたオブジェクトも処理\n              if (typeof value === 'object' && value !== null) {\n                form.setValue(key, value);\n              } else {\n                form.setValue(key, value);\n              }\n            });\n          }\n        } catch (error) {\n          console.error('Failed to fetch resource:', error);\n          setError(t('fetch-error'));\n        }\n      };\n\n      getResource();\n    }\n  }, [isEditMode, resourceId, apiEndpoint, form, t]);\n\n  // フォーム送信処理\n  const onSubmit = async (data: z.infer<typeof formSchema>) => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // 送信前のデータ整形\n      const formattedData = formatFormData ? formatFormData(data) : data;\n\n      // リソースの作成または更新\n      let result;\n      if (isEditMode && resourceId) {\n        result = await updateResource(apiEndpoint, resourceId, {\n          type: resourceType,\n          data: formattedData,\n        });\n      } else {\n        result = await createResource(apiEndpoint, {\n          type: resourceType,\n          data: formattedData,\n        });\n      }\n\n      // 成功時の処理\n      if (result) {\n        toast.success(\n          successMessage || (isEditMode ? t('updated-success') : t('created-success')), \n          { id: 'resource-action' }\n        );\n        router.push(redirectPath);\n      }\n    } catch (e) {\n      console.error('Form submission error:', e);\n      setError(errorMessage || (isEditMode ? t('updated-error') : t('created-error')));\n      toast.error(\n        errorMessage || (isEditMode ? t('updated-error') : t('created-error')), \n        { id: 'resource-action' }\n      );\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // キャンセルボタンのハンドラー\n  const onCancel = () => {\n    router.push(redirectPath);\n  };\n\n  return (\n    <Card>\n      <CardContent className=\"p-6\">\n        <div className=\"space-y-6\">\n          <div>\n            <h1 className=\"text-2xl font-semibold mb-2\">{title}</h1>\n          </div>\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n              {safeFields.map(field => (\n                <FieldRenderer \n                  key={`field-${field.name}`}\n                  field={field} \n                  form={form}\n                  translationNamespace=\"components.resource-form\"\n                  codeEditor={CodeEditor}\n                />\n              ))}\n              <div className=\"flex justify-end gap-2\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={onCancel}\n                >\n                  {t('cancel')}\n                </Button>\n                <Button\n                  type=\"submit\"\n                  disabled={loading}\n                >\n                  {loading ? (\n                    <div className=\"flex items-center\">\n                      <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n                      {isEditMode ? t('updating') : t('creating')}\n                    </div>\n                  ) : (\n                    isEditMode ? t('update') : t('create')\n                  )}\n                </Button>\n              </div>\n            </form>\n          </Form>\n        </div>\n      </CardContent>\n    </Card>\n  );\n};\n\n/**\n * 複数ステップリソース作成フォーム\n */\nexport const MultiStepResourceForm: React.FC<MultiStepResourceFormProps> = ({\n  title,\n  resourceType,\n  steps,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  formatFormData,\n  defaultValues = {},\n  resourceId,\n  isEditMode = false\n}) => {\n  const router = useRouter();\n  const t = useTranslations('components.resource-form');\n  const [currentStepIndex, setCurrentStepIndex] = useState(0);\n  const [allStepsData, setAllStepsData] = useState<Record<string, any>>({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // 安全に手順を処理\n  const safeSteps = Array.isArray(steps) ? steps : [];\n  const currentStepData = safeSteps[currentStepIndex] || { fields: [] };\n\n  // 現在のステップのスキーマ生成\n  const formSchema = generateSchema(currentStepData.fields, t, getValidator);\n\n  // react-hook-formの設定\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: generateDefaultValues(currentStepData.fields, {\n      ...defaultValues,\n      ...allStepsData,\n    }),\n  });\n\n  // リソースの取得（編集モードの場合）\n  useEffect(() => {\n    if (isEditMode && resourceId && currentStepIndex === 0) {\n      const getResource = async () => {\n        try {\n          const data = await fetchResource(apiEndpoint, resourceId);\n          if (data) {\n            setAllStepsData(data);\n            // 現在のステップのデータだけをフォームにセット\n            Object.entries(data).forEach(([key, value]) => {\n              form.setValue(key, value);\n            });\n          }\n        } catch (error) {\n          console.error('Failed to fetch resource:', error);\n          setError(t('fetch-error'));\n        }\n      };\n\n      getResource();\n    }\n  }, [isEditMode, resourceId, apiEndpoint, form, currentStepIndex, t]);\n\n  // 次のステップへ進む\n  const handleNextStep = async () => {\n    const isValid = await form.trigger();\n    \n    if (!isValid) return;\n\n    const currentData = form.getValues();\n    const updatedAllData = { ...allStepsData, ...currentData };\n    \n    setAllStepsData(updatedAllData);\n\n    if (currentStepIndex < steps.length - 1) {\n      setCurrentStepIndex(prev => prev + 1);\n    } else {\n      // 最後のステップでは送信処理を行う\n      handleSubmit(updatedAllData);\n    }\n  };\n\n  // 前のステップに戻る\n  const handlePrevStep = () => {\n    if (currentStepIndex > 0) {\n      const currentData = form.getValues();\n      setAllStepsData(prev => ({ ...prev, ...currentData }));\n      setCurrentStepIndex(prev => prev - 1);\n    }\n  };\n\n  // フォーム送信処理\n  const handleSubmit = async (data: Record<string, any>) => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      // 送信前のデータ整形\n      const formattedData = formatFormData ? formatFormData(data) : data;\n\n      // リソースの作成または更新\n      let result;\n      if (isEditMode && resourceId) {\n        result = await updateResource(apiEndpoint, resourceId, {\n          type: resourceType,\n          data: formattedData,\n        });\n      } else {\n        result = await createResource(apiEndpoint, {\n          type: resourceType,\n          data: formattedData,\n        });\n      }\n\n      // 成功時の処理\n      if (result) {\n        toast.success(\n          successMessage || (isEditMode ? t('updated-success') : t('created-success')), \n          { id: 'resource-action' }\n        );\n        router.push(redirectPath);\n      }\n    } catch (e) {\n      console.error('Form submission error:', e);\n      setError(errorMessage || (isEditMode ? t('updated-error') : t('created-error')));\n      toast.error(\n        errorMessage || (isEditMode ? t('updated-error') : t('created-error')), \n        { id: 'resource-action' }\n      );\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // キャンセルボタンのハンドラー\n  const onCancel = () => {\n    router.push(redirectPath);\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"mb-4\">\n        <h1 className=\"text-2xl font-semibold\">{title}</h1>\n        {steps.length > 1 && (\n          <div className=\"mt-4\">\n            <div className=\"flex justify-between mb-1\">\n              <span className=\"text-sm\">{t('step')} {currentStepIndex + 1} / {steps.length}</span>\n              <span className=\"text-sm\">{currentStepData.title}</span>\n            </div>\n            <Progress value={((currentStepIndex + 1) / steps.length) * 100} className=\"h-2\" />\n          </div>\n        )}\n      </div>\n\n      <Card>\n        <CardContent className=\"p-6\">\n          {currentStepData.description && (\n            <p className=\"text-muted-foreground mb-6\">{currentStepData.description}</p>\n          )}\n\n          <Form {...form}>\n            <form className=\"space-y-6\">\n              {currentStepData.fields.map(field => (\n                <FieldRenderer\n                  key={`field-${field.name}`}\n                  field={field}\n                  form={form}\n                  translationNamespace=\"components.resource-form\"\n                  codeEditor={CodeEditor}\n                />\n              ))}\n            </form>\n          </Form>\n        </CardContent>\n      </Card>\n\n      {error && (\n        <Alert variant=\"destructive\">\n          <AlertCircle className=\"h-4 w-4\" />\n          <AlertDescription>\n            {error}\n          </AlertDescription>\n        </Alert>\n      )}\n\n      <div className=\"flex justify-between\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          onClick={currentStepIndex === 0 ? onCancel : handlePrevStep}\n        >\n          {currentStepIndex === 0 ? t('cancel') : t('prev')}\n        </Button>\n        <Button\n          type=\"button\"\n          onClick={handleNextStep}\n          disabled={loading}\n        >\n          {loading ? (\n            <div className=\"flex items-center\">\n              <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n              {isEditMode ? t('updating') : t('creating')}\n            </div>\n          ) : (\n            currentStepIndex === steps.length - 1 ? (isEditMode ? t('update') : t('create')) : t('next')\n          )}\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default ResourceForm; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/field-renderer.tsx",
      "content": "'use client';\n\nimport React from 'react';\nimport { useFieldArray } from 'react-hook-form';\nimport { Input } from '@/registry/new-york/ui/input';\nimport { Textarea } from '@/registry/new-york/ui/textarea';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/registry/new-york/ui/select';\nimport {\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n  FormDescription,\n} from '@/registry/new-york/ui/form';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { X } from 'lucide-react';\nimport { useTranslations } from 'next-intl';\nimport { \n  CommonFieldDefinition, \n  CommonFieldObjectDefinition \n} from './resource-form-utils';\nimport { SupportedLanguage } from './code-editor';\nimport { getValidator } from './code-utils';\n\ninterface ArrayItemRecord {\n  [key: string]: string;\n}\n\ntype FieldRendererProps = {\n  field: CommonFieldDefinition;\n  form: any;\n  fieldNamePrefix?: string;\n  translationNamespace?: string;\n  codeEditor?: React.ComponentType<{\n    value: string;\n    onChange: (value: string) => void;\n    language?: SupportedLanguage;\n    height?: string;\n    placeholder?: string;\n    disabled?: boolean;\n    readOnly?: boolean;\n    showValidation?: boolean;\n    validator?: (content: string) => { isValid: boolean; error?: string };\n    theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light';\n  }>;\n};\n\nexport const FieldRenderer: React.FC<FieldRendererProps> = ({\n  field,\n  form,\n  fieldNamePrefix = '',\n  translationNamespace = 'components.resource-create',\n  codeEditor: CodeEditor\n}) => {\n  const t = useTranslations(translationNamespace);\n  const fieldName = fieldNamePrefix ? `${fieldNamePrefix}.${field.name}` : field.name;\n\n  // readOnlyメッセージの表示\n  const renderReadOnlyMessage = () => {\n    if (field.readOnly && field.readOnlyMessage) {\n      return (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      );\n    }\n    return null;\n  };\n\n  // カスタムコンポーネントの処理\n  if (field.type === 'custom' && field.render) {\n    return (\n      <div key={`form-field-${fieldName}`}>\n        {field.render({ \n          values: form.getValues(), \n          form \n        })}\n      </div>\n    );\n  }\n\n  // ユニット入力の処理\n  if (field.type === 'unit-input') {\n    return (\n      <div key={`form-field-${fieldName}`} className=\"space-y-2\">\n        <div className=\"space-y-1\">\n          <FormLabel className=\"text-sm font-medium\">\n            {field.label}\n            {field.validation?.required && (\n              <span className=\"text-destructive ml-1\">*</span>\n            )}\n          </FormLabel>\n          {field.description && (\n            <FormDescription className=\"text-xs\">\n              {field.description}\n            </FormDescription>\n          )}\n          {renderReadOnlyMessage()}\n        </div>\n\n        <div className=\"flex flex-col md:flex-row gap-2 w-full\">\n          <div className=\"flex-grow\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Value`}\n              render={({ field: formField }) => (\n                <FormControl>\n                  <Input\n                    type=\"number\"\n                    placeholder={field.placeholder}\n                    className={field.readOnly ? 'bg-muted' : 'h-10'}\n                    value={formField.value}\n                    onChange={(e) => {\n                      formField.onChange(e);\n                      const unit = form.getValues(`${fieldName}Unit`);\n                      form.setValue(fieldName, `${e.target.value}${unit}`);\n                    }}\n                    readOnly={field.readOnly}\n                  />\n                </FormControl>\n              )}\n            />\n          </div>\n\n          <div className=\"w-full md:w-[160px]\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Unit`}\n              render={({ field: formField }) => (\n                <Select\n                  value={formField.value}\n                  defaultValue={field.defaultUnit}\n                  onValueChange={(value) => {\n                    formField.onChange(value);\n                    const numValue = form.getValues(`${fieldName}Value`);\n                    form.setValue(fieldName, `${numValue}${value}`);\n                  }}\n                  disabled={field.disabled || field.readOnly}\n                >\n                  <FormControl>\n                    <SelectTrigger className={field.readOnly ? 'bg-muted h-10' : 'h-10'}>\n                      <SelectValue />\n                    </SelectTrigger>\n                  </FormControl>\n                  <SelectContent>\n                    {field.units?.map((unit) => (\n                      <SelectItem\n                        key={`${fieldName}-unit-${unit.value}`}\n                        value={unit.value}\n                      >\n                        {unit.label}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              )}\n            />\n          </div>\n        </div>\n        <FormMessage className=\"text-xs\" />\n      </div>\n    );\n  }\n\n  // コードエディタの処理\n  if (field.type === 'code' && CodeEditor) {\n    const language = (field.language || 'plaintext') as SupportedLanguage;\n    const validator = getValidator(language);\n\n    return (\n      <FormField\n        key={`form-field-${fieldName}`}\n        control={form.control}\n        name={fieldName}\n        render={({ field: formField }) => (\n          <FormItem className=\"space-y-2\">\n            <div className=\"space-y-1\">\n              <FormLabel className=\"text-sm font-medium\">\n                {field.label}\n                {field.validation?.required && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n              </FormLabel>\n              {field.description && (\n                <FormDescription className=\"text-xs\">\n                  {field.description}\n                </FormDescription>\n              )}\n              {renderReadOnlyMessage()}\n            </div>\n            <FormControl>\n              <CodeEditor\n                value={formField.value}\n                onChange={(value: string) => {\n                  if (!field.readOnly) {\n                    formField.onChange(value);\n                    field.onChange?.(value);\n                  }\n                }}\n                language={language}\n                readOnly={field.readOnly}\n                height={field.height || '300px'}\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                showValidation={field.validation?.codeValidation !== false}\n                validator={validator}\n                theme={field.theme || 'vs-dark'}\n              />\n            </FormControl>\n            <FormMessage className=\"text-xs\" />\n          </FormItem>\n        )}\n      />\n    );\n  }\n\n  // 配列フィールドの処理\n  if (field.type === 'array') {\n    return <ArrayFieldRenderer field={field} form={form} fieldName={fieldName} t={t} />;\n  }\n\n  // 一般的なフィールドの処理（テキスト、数値、メール、パスワード、セレクト、テキストエリア）\n  return (\n    <FormField\n      key={`form-field-${fieldName}`}\n      control={form.control}\n      name={fieldName}\n      render={({ field: formField }) => (\n        <FormItem className=\"space-y-2\">\n          <div className=\"space-y-1\">\n            <FormLabel className=\"text-sm font-medium\">\n              {field.label}\n              {field.validation?.required && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n            </FormLabel>\n            {field.description && (\n              <FormDescription className=\"text-xs\">\n                {field.description}\n              </FormDescription>\n            )}\n            {renderReadOnlyMessage()}\n          </div>\n          <FormControl>\n            {field.type === 'select' ? (\n              <Select\n                value={formField.value || ''}\n                onValueChange={(value) => {\n                  if (!field.readOnly) {\n                    formField.onChange(value);\n                    field.onChange?.(value);\n                  }\n                }}\n                disabled={field.disabled || field.readOnly}\n              >\n                <SelectTrigger className={field.readOnly ? 'bg-muted h-10' : 'h-10'}>\n                  <SelectValue placeholder={field.placeholder} />\n                </SelectTrigger>\n                <SelectContent>\n                  {field.options?.map((option) => (\n                    <SelectItem\n                      key={`${fieldName}-option-${option.value}`}\n                      value={option.value}\n                    >\n                      {option.label}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            ) : field.type === 'textarea' ? (\n              <Textarea\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                readOnly={field.readOnly}\n                className={field.readOnly ? 'bg-muted' : ''}\n                {...formField}\n                onChange={(e) => {\n                  if (!field.readOnly) {\n                    formField.onChange(e);\n                    field.onChange?.(e.target.value);\n                  }\n                }}\n              />\n            ) : (\n              <Input\n                type={field.type}\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                readOnly={field.readOnly}\n                className={field.readOnly ? 'bg-muted' : ''}\n                {...formField}\n                onChange={(e) => {\n                  if (!field.readOnly) {\n                    formField.onChange(e);\n                    field.onChange?.(e.target.value);\n                  }\n                }}\n              />\n            )}\n          </FormControl>\n          <FormMessage className=\"text-xs\" />\n        </FormItem>\n      )}\n    />\n  );\n};\n\n// 配列フィールドのレンダリングを処理する内部コンポーネント\nconst ArrayFieldRenderer: React.FC<{\n  field: CommonFieldDefinition;\n  form: any;\n  fieldName: string;\n  t: (key: string, params?: any) => string;\n}> = ({ field, form, fieldName, t }) => {\n  const { fields, append, remove } = useFieldArray({\n    control: form.control,\n    name: fieldName,\n  });\n\n  const addNewItem = () => {\n    if (field.readOnly) return;\n\n    if (field.itemType === 'object' && field.fields) {\n      const newItem = field.fields.reduce<Record<string, any>>((acc, fieldItem) => {\n        acc[fieldItem.name] = fieldItem.type === 'number' ? null : '';\n        return acc;\n      }, {});\n      append(newItem);\n    } else {\n      append('');\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <FormLabel>\n          {field.label}\n          {field.validation?.required && (\n            <span className=\"text-destructive ml-1\">*</span>\n          )}\n        </FormLabel>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={addNewItem}\n          disabled={field.readOnly}\n        >\n          {t('add')}\n        </Button>\n      </div>\n      {field.description && (\n        <FormDescription className=\"text-xs\">\n          {field.description}\n        </FormDescription>\n      )}\n      {field.readOnly && field.readOnlyMessage && (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      )}\n\n      {fields.map((arrayField, index) => (\n        <div key={arrayField.id} className=\"relative\">\n          {field.itemType === 'object' ? (\n            <div className=\"flex gap-4 items-start\">\n              {field.fields?.map((subField) => (\n                <FormField\n                  key={`${arrayField.id}-${subField.name}`}\n                  control={form.control}\n                  name={`${fieldName}.${index}.${subField.name}`}\n                  render={({ field: formField }) => (\n                    <FormItem className=\"flex-1\">\n                      <FormLabel>{subField.label}</FormLabel>\n                      <FormControl>\n                        {subField.type === 'select' ? (\n                          <Select\n                            value={formField.value?.toString() || ''}\n                            onValueChange={(value) => {\n                              if (!field.readOnly) {\n                                formField.onChange(value);\n                                if (subField.onChange) {\n                                  subField.onChange(value);\n                                }\n                              }\n                            }}\n                            disabled={subField.disabled || field.readOnly}\n                          >\n                            <SelectTrigger className={field.readOnly ? 'bg-muted' : ''}>\n                              <SelectValue\n                                placeholder={subField.placeholder || t('select', { label: subField.label })}\n                              />\n                            </SelectTrigger>\n                            <SelectContent>\n                              {subField.options?.map((option) => (\n                                <SelectItem\n                                  key={`${subField.name}-${index}-option-${option.value}`}\n                                  value={option.value}\n                                >\n                                  {option.label}\n                                </SelectItem>\n                              ))}\n                            </SelectContent>\n                          </Select>\n                        ) : (\n                          <Input\n                            type={subField.type}\n                            placeholder={subField.placeholder}\n                            className={field.readOnly ? 'bg-muted' : ''}\n                            disabled={subField.disabled || field.readOnly}\n                            readOnly={field.readOnly}\n                            value={formField.value ?? ''}\n                            onChange={(e) => {\n                              if (!field.readOnly) {\n                                const value = subField.type === 'number'\n                                  ? e.target.value === '' ? null : Number(e.target.value)\n                                  : e.target.value;\n                                formField.onChange(value);\n                                if (subField.onChange) {\n                                  subField.onChange(value);\n                                }\n                              }\n                            }}\n                          />\n                        )}\n                      </FormControl>\n                      <FormMessage />\n                      {subField.description && (\n                        <FormDescription>{subField.description}</FormDescription>\n                      )}\n                    </FormItem>\n                  )}\n                />\n              ))}\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"mt-8\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          ) : (\n            <div className=\"flex gap-2\">\n              <FormField\n                control={form.control}\n                name={`${fieldName}.${index}`}\n                render={({ field: formField }) => (\n                  <FormItem className=\"flex-1\">\n                    <FormControl>\n                      <Input\n                        className={field.readOnly ? 'bg-muted' : ''}\n                        readOnly={field.readOnly}\n                        disabled={field.readOnly}\n                        {...formField}\n                        onChange={(e) => {\n                          if (!field.readOnly) {\n                            formField.onChange(e);\n                          }\n                        }}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default FieldRenderer; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/code-editor.tsx",
      "content": "'use client';\n\nimport React, { useRef, useEffect, useState } from 'react';\nimport dynamic from 'next/dynamic';\nimport { Loader2 } from 'lucide-react';\nimport { useTheme } from 'next-themes';\nimport { \n  getValidator, \n  applyMarkersToModel,\n  MonacoMarker,\n  getLanguagePlugin,\n  getLanguageLabel\n} from './code-utils';\nimport { initializeLanguagePlugins } from './language-plugins';\n\n// 初期化時に言語プラグインをロード\nif (typeof window !== 'undefined') {\n  // クライアントサイドでのみ実行\n  initializeLanguagePlugins();\n}\n\n// Monaco Editorをクライアントサイドでのみロードするために動的にインポート\nconst MonacoEditor = dynamic(() => import('@monaco-editor/react'), {\n  ssr: false,\n  loading: () => (\n    <div className=\"flex items-center justify-center min-h-[300px] border rounded-md bg-muted/30\">\n      <Loader2 className=\"h-6 w-6 animate-spin text-muted-foreground\" />\n    </div>\n  ),\n});\n\n// サポートする言語とそのバリデーション関数の型\ntype LanguageValidatorFn = (content: string) => { isValid: boolean; error?: string; markers?: MonacoMarker[] };\nexport type SupportedLanguage = 'yaml' | 'json' | 'javascript' | 'typescript' | 'html' | 'css' | 'markdown' | 'plaintext';\n\n// プロパティの型定義\ntype CodeEditorProps = {\n  value: string;\n  onChange: (value: string) => void;\n  language?: SupportedLanguage;\n  height?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  showValidation?: boolean;\n  validator?: LanguageValidatorFn;\n  theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light';\n  useMarkers?: boolean;\n};\n\nexport const CodeEditor: React.FC<CodeEditorProps> = ({\n  value,\n  onChange,\n  language = 'plaintext',\n  height = '300px',\n  placeholder = 'コードを入力してください',\n  disabled = false,\n  readOnly = false,\n  showValidation = true,\n  validator: customValidator,\n  theme: propTheme,\n  useMarkers = true,\n}) => {\n  const monacoRef = useRef<any>(null);\n  const editorRef = useRef<any>(null);\n  const modelRef = useRef<any>(null);\n  const [error, setError] = useState<string | null>(null);\n  const { resolvedTheme } = useTheme();\n  \n  // テーマの決定: プロパティで指定された場合はそれを使用、それ以外はアプリケーションのテーマに従う\n  const theme = propTheme || (resolvedTheme === 'dark' ? 'vs-dark' : 'vs');\n  \n  // システムテーマが変更された時にエディタのテーマも更新\n  useEffect(() => {\n    if (!propTheme && editorRef.current && monacoRef.current) {\n      const newTheme = resolvedTheme === 'dark' ? 'vs-dark' : 'vs';\n      monacoRef.current.editor.setTheme(newTheme);\n    }\n  }, [resolvedTheme, propTheme]);\n  \n  // バリデーターの取得 (カスタムバリデーターが渡されていればそれを使用、なければプラグインシステムから取得)\n  const validator = customValidator || getValidator(language);\n  \n  // バリデーション処理を共通化\n  const validateContent = (content: string) => {\n    if (!showValidation || !validator) return;\n    \n    const result = validator(content);\n    \n    if (!result.isValid) {\n      setError(result.error || '不正なフォーマットです');\n      \n      // Markersの適用（useMarkersがtrueかつmarkersが存在する場合）\n      if (useMarkers && result.markers && monacoRef.current && modelRef.current) {\n        applyMarkersToModel(monacoRef.current, modelRef.current, result.markers);\n      }\n    } else {\n      setError(null);\n      \n      // エラーがなくなったらマーカーをクリア\n      if (useMarkers && monacoRef.current && modelRef.current) {\n        applyMarkersToModel(monacoRef.current, modelRef.current, []);\n      }\n    }\n  };\n  \n  // エディタが初期化されたときの処理\n  const handleEditorDidMount = (editor: any, monaco: any) => {\n    editorRef.current = editor;\n    monacoRef.current = monaco;\n    modelRef.current = editor.getModel();\n\n    // 初期テーマを明示的に設定\n    const currentTheme = resolvedTheme === 'dark' ? 'vs-dark' : 'vs';\n    monaco.editor.setTheme(currentTheme);\n\n    // プレースホルダーテキストの設定\n    if (!value && placeholder) {\n      editor.getModel()?.setValue(placeholder);\n      editor.onDidFocusEditorText(() => {\n        if (editor.getValue() === placeholder) {\n          editor.getModel()?.setValue('');\n        }\n      });\n      editor.onDidBlurEditorText(() => {\n        if (editor.getValue() === '') {\n          editor.getModel()?.setValue(placeholder);\n        }\n      });\n    }\n\n    // 言語プラグインのMonaco設定を適用\n    const languagePlugin = getLanguagePlugin(language);\n    if (languagePlugin?.setupMonaco) {\n      languagePlugin.setupMonaco(monaco);\n    }\n\n    // 初期バリデーション\n    if (value) {\n      validateContent(value);\n    }\n  };\n\n  // エディタの内容が変更されたときの処理\n  const handleEditorChange = (newValue: string | undefined) => {\n    if (readOnly || disabled) return;\n    \n    const content = newValue || '';\n    onChange(content);\n\n    // バリデーション\n    validateContent(content);\n  };\n\n  // 値が変更されたときのバリデーション\n  useEffect(() => {\n    if (value) {\n      validateContent(value);\n    }\n  }, [value]);\n\n  // クリーンアップ関数\n  useEffect(() => {\n    return () => {\n      // コンポーネントがアンマウントされるときにマーカーをクリア\n      if (useMarkers && monacoRef.current && modelRef.current) {\n        applyMarkersToModel(monacoRef.current, modelRef.current, []);\n      }\n    };\n  }, [useMarkers]);\n\n  // 言語ラベルの取得\n  const languageLabel = getLanguageLabel(language);\n\n  return (\n    <div className=\"space-y-2\">\n      <div \n        className={`border rounded-md overflow-hidden relative ${error ? 'border-destructive' : 'border-input'} ${readOnly ? 'bg-muted/30' : ''}`}\n      >\n        {/* 言語ラベルバッジ */}\n        <div className=\"absolute top-1 right-1 z-10 px-2 py-0.5 rounded bg-primary/10 text-xs font-medium text-primary-foreground backdrop-blur-sm\">\n          {languageLabel}\n        </div>\n\n        <MonacoEditor\n          value={value}\n          onChange={handleEditorChange}\n          language={language}\n          height={height}\n          theme={theme}\n          options={{\n            minimap: { enabled: true },\n            scrollBeyondLastLine: false,\n            lineNumbers: 'on',\n            folding: true,\n            wordWrap: 'on',\n            automaticLayout: true,\n            contextmenu: true,\n            scrollbar: {\n              useShadows: false,\n              verticalScrollbarSize: 10,\n              horizontalScrollbarSize: 10,\n              alwaysConsumeMouseWheel: false\n            },\n            lineNumbersMinChars: 3,\n            readOnly: readOnly || disabled,\n            renderLineHighlight: 'all',\n          }}\n          onMount={handleEditorDidMount}\n        />\n      </div>\n      {showValidation && error && !useMarkers && (\n        <div className=\"text-xs text-destructive\">{error}</div>\n      )}\n    </div>\n  );\n};\n\nexport default CodeEditor; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/resource-form-utils.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\nimport { SupportedLanguage } from './code-editor';\n\n/**\n * 共通の型定義\n */\nexport type SelectOption = {\n  value: string;\n  label: string;\n};\n\nexport type UnitOption = SelectOption;\n\nexport type ValidationPattern = {\n  value: string;\n  flags?: string;\n  message: string;\n};\n\nexport type BaseFieldValidation = {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: ValidationPattern;\n  codeValidation?: boolean;\n};\n\nexport type BaseFieldDefinition = {\n  name: string;\n  label: string;\n  placeholder?: string;\n  description?: string;\n  validation?: BaseFieldValidation;\n  disabled?: boolean;\n  onChange?: (value: any) => void;\n  defaultValue?: string | number;\n  readOnly?: boolean;\n  readOnlyMessage?: string;\n};\n\n/**\n * すべてのフィールドタイプの共通定義\n */\nexport type CommonFieldType = \n  'text' | 'number' | 'email' | 'password' | 'select' | \n  'array' | 'unit-input' | 'textarea' | 'yaml' | 'custom' | 'code';\n\nexport type CommonFieldObjectDefinition = Omit<BaseFieldDefinition, 'onChange'> & {\n  type: 'text' | 'number' | 'email' | 'password' | 'select';\n  options?: SelectOption[];\n  onChange?: (value: any) => void;\n};\n\nexport type CommonFieldDefinition = BaseFieldDefinition & {\n  type: CommonFieldType;\n  // 各タイプに必要な追加プロパティ\n  options?: SelectOption[];         // select用\n  units?: UnitOption[];             // unit-input用\n  defaultUnit?: string;             // unit-input用\n  itemType?: 'text' | 'object';     // array+object用\n  fields?: CommonFieldObjectDefinition[]; // array+object用\n  render?: (props: { values: any; form: any }) => React.ReactNode; // custom用\n  language?: SupportedLanguage;     // code用\n  height?: string;                  // code用\n  theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light'; // code用\n};\n\n/**\n * 複数ステップフォーム用の定義\n */\nexport type StepDefinition = {\n  title: string;\n  description?: string;\n  fields: CommonFieldDefinition[];\n};\n\n/**\n * 共通のスキーマ生成関数\n */\nexport const generateFieldSchema = (\n  field: {\n    name: string;\n    label: string;\n    type?: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, any>) => string\n) => {\n  let fieldSchema = z.string();\n\n  if (field.validation) {\n    if (field.validation.required) {\n      fieldSchema = fieldSchema.min(1, t('need', { label: field.label }));\n    }\n\n    if (field.validation.maxLength) {\n      fieldSchema = fieldSchema.max(\n        field.validation.maxLength,\n        t('textlesser', { label: field.label, maxLength: field.validation.maxLength })\n      );\n    }\n\n    if (field.validation.pattern) {\n      const regex = new RegExp(\n        field.validation.pattern.value,\n        field.validation.pattern.flags\n      );\n      fieldSchema = fieldSchema.regex(regex, field.validation.pattern.message);\n    }\n  }\n\n  return fieldSchema;\n};\n\n/**\n * 数値フィールド用の検証\n */\nexport const addNumberValidation = (\n  fieldSchema: z.ZodString,\n  field: {\n    label: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, any>) => string\n) => {\n  return fieldSchema.superRefine((val, ctx) => {\n    if (val === '') return;\n\n    const num = Number(val);\n    if (isNaN(num)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('number'),\n      });\n      return;\n    }\n\n    if (field.validation?.min !== undefined && num < field.validation.min) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('greater', { label: field.label, min: field.validation.min }),\n      });\n    }\n\n    if (field.validation?.max !== undefined && num > field.validation.max) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('lesser', { label: field.label, max: field.validation.max }),\n      });\n    }\n  });\n};\n\n/**\n * ZODスキーマをフィールドタイプに基づいて生成\n */\nexport const generateFieldSchemaByType = (\n  field: CommonFieldDefinition,\n  t: (key: string, params?: Record<string, any>) => string,\n  getValidatorFn?: (language: SupportedLanguage) => (content: string) => { isValid: boolean; error?: string; markers?: any[] }\n) => {\n  let fieldSchema = generateFieldSchema(field, t);\n\n  if (field.type === 'number') {\n    return addNumberValidation(fieldSchema, field, t);\n  } \n  \n  if (field.type === 'code' && field.validation?.codeValidation && getValidatorFn && field.language) {\n    const validator = getValidatorFn(field.language);\n    if (validator) {\n      return fieldSchema.superRefine((val, ctx) => {\n        if (!val) return;\n        \n        const result = validator(val);\n        if (!result.isValid) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: result.error || 'Invalid code format',\n          });\n        }\n      });\n    }\n  }\n\n  return fieldSchema;\n};\n\n/**\n * ネストしたオブジェクトのスキーマを処理する関数\n */\nexport const processNestedSchema = (obj: any): any => {\n  const processed: { [key: string]: any } = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (value instanceof z.ZodType) {\n      processed[key] = value;\n    } else if (typeof value === 'object') {\n      processed[key] = z.object(processNestedSchema(value));\n    }\n  }\n\n  return processed;\n};\n\n/**\n * ネストしたフィールドのパスを処理する関数\n */\nexport const handleNestedField = (\n  obj: Record<string, any>,\n  paths: string[],\n  schema: z.ZodType,\n  fieldType?: string,\n  fieldConfig?: any\n) => {\n  const [first, ...rest] = paths;\n  if (!first) return;\n\n  if (rest.length === 0) {\n    if (fieldType === 'array') {\n      if (fieldConfig?.itemType === 'object' && fieldConfig?.fields) {\n        const objectSchema: Record<string, z.ZodType> = {};\n        fieldConfig.fields.forEach((subField: any) => {\n          objectSchema[subField.name] = z.string();\n        });\n        obj[first] = z.array(z.object(objectSchema));\n      } else {\n        obj[first] = z.array(z.string());\n      }\n    } else {\n      obj[first] = schema;\n    }\n  } else {\n    obj[first] = obj[first] || {};\n    handleNestedField(obj[first] as Record<string, any>, rest, schema, fieldType, fieldConfig);\n  }\n};\n\n/**\n * ネストした値を設定するヘルパー関数\n */\nexport const setNestedValue = (obj: Record<string, any>, path: string[], value: any) => {\n  if (path.length === 0) return obj;\n\n  let current = obj;\n  const lastIndex = path.length - 1;\n\n  for (let i = 0; i < lastIndex; i++) {\n    const key = path[i];\n    if (key) {\n      current[key] = current[key] || {};\n      current = current[key];\n    }\n  }\n\n  const lastKey = path[lastIndex];\n  if (lastKey) {\n    current[lastKey] = value;\n  }\n\n  return obj;\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/schema-generator.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\nimport { \n  CommonFieldDefinition, \n  generateFieldSchemaByType, \n  handleNestedField,\n  processNestedSchema\n} from './resource-form-utils';\nimport { getValidator } from './code-utils';\nimport { SupportedLanguage } from './code-editor';\n\n/**\n * フィールド定義からZodスキーマを生成する関数\n */\nexport const generateSchema = (\n  fields: CommonFieldDefinition[],\n  t: (key: string, params?: Record<string, any>) => string,\n  codeValidator?: (language: SupportedLanguage) => (content: string) => { isValid: boolean; error?: string; markers?: any[] }\n) => {\n  const schemaObject: Record<string, any> = {};\n\n  // バリデータの取得関数（指定されていなければデフォルトのgetValidatorを使用）\n  const getValidatorFn = codeValidator || getValidator;\n\n  fields.forEach(field => {\n    if (field.type === 'unit-input') {\n      // ユニット入力には2つのフィールドが必要\n      const valueSchema = generateFieldSchemaByType(field, t, getValidatorFn);\n      const unitSchema = z.string().min(1, t('unit'));\n\n      schemaObject[`${field.name}Value`] = valueSchema;\n      schemaObject[`${field.name}Unit`] = unitSchema;\n    } else {\n      // 通常のフィールド\n      const fieldSchema = generateFieldSchemaByType(field, t, getValidatorFn);\n\n      const fieldPath = field.name.split('.');\n      if (fieldPath.length > 1) {\n        // ネストされたフィールド\n        handleNestedField(schemaObject, fieldPath, fieldSchema, field.type, field);\n      } else {\n        // トップレベルフィールド\n        if (field.type === 'array') {\n          if (field.itemType === 'object' && field.fields) {\n            const objectSchema: Record<string, z.ZodType> = {};\n            field.fields.forEach(subField => {\n              objectSchema[subField.name] = z.string();\n            });\n            schemaObject[field.name] = z.array(z.object(objectSchema));\n          } else {\n            schemaObject[field.name] = z.array(z.string());\n          }\n        } else {\n          schemaObject[field.name] = fieldSchema;\n        }\n      }\n    }\n  });\n\n  return z.object(processNestedSchema(schemaObject));\n};\n\n/**\n * デフォルト値を生成する関数\n */\nexport const generateDefaultValues = (\n  fields: CommonFieldDefinition[],\n  existingValues: Record<string, any> = {}\n): Record<string, any> => {\n  return fields.reduce((acc: Record<string, any>, field) => {\n    if (field.type === 'unit-input') {\n      const defaultUnit = field.defaultUnit || field.units?.[0]?.value || '';\n      acc[`${field.name}Value`] = field.defaultValue?.toString() || '';\n      acc[`${field.name}Unit`] = defaultUnit;\n    } else if (field.type === 'array') {\n      acc[field.name] = existingValues[field.name] || [];\n    } else {\n      acc[field.name] = field.defaultValue?.toString() || existingValues[field.name] || '';\n    }\n    return acc;\n  }, {});\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/code-utils.ts",
      "content": "import { SupportedLanguage } from './code-editor';\n\n// プラグインインターフェース\nexport interface LanguagePlugin {\n  language: SupportedLanguage;\n  validate: (content: string) => { isValid: boolean; error?: string; markers?: MonacoMarker[] };\n  getModelOptions?: () => any;\n  setupMonaco?: (monaco: any) => void;\n}\n\n// Monaco Editorのマーカー型定義\nexport interface MonacoMarker {\n  startLineNumber: number;\n  startColumn: number;\n  endLineNumber: number;\n  endColumn: number;\n  message: string;\n  severity: number; // monaco.MarkerSeverity の値\n}\n\n// プラグインレジストリ\nconst languagePlugins: Map<SupportedLanguage, LanguagePlugin> = new Map();\n\n// プラグインの登録\nexport function registerLanguagePlugin(plugin: LanguagePlugin) {\n  languagePlugins.set(plugin.language, plugin);\n}\n\n// プラグインの取得\nexport function getLanguagePlugin(language: SupportedLanguage): LanguagePlugin | undefined {\n  return languagePlugins.get(language);\n}\n\n// バリデーターの取得\nexport function getValidator(language: SupportedLanguage) {\n  return languagePlugins.get(language)?.validate || (() => ({ isValid: true, error: undefined, markers: [] }));\n}\n\n// Monaco EditorのMarkers APIを使用してエラーを表示する関数\nexport function applyMarkersToModel(monaco: any, model: any, markers: MonacoMarker[], owner: string = 'linter') {\n  if (model && monaco) {\n    monaco.editor.setModelMarkers(model, owner, markers);\n  }\n}\n\n// 各言語のサンプル\nexport const codeExamples: Record<SupportedLanguage, string> = {\n  yaml: `# 基本的なYAMLの例\nname: example-service\nversion: 1.0.0\ndescription: A simple example service\nspec:\n  replicas: 3\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8080\n  selector:\n    app: example\n`,\n  json: `{\n  \"name\": \"example-service\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A simple example service\",\n  \"spec\": {\n    \"replicas\": 3,\n    \"ports\": [\n      {\n        \"name\": \"http\",\n        \"port\": 80,\n        \"targetPort\": 8080\n      }\n    ],\n    \"selector\": {\n      \"app\": \"example\"\n    }\n  }\n}`,\n  javascript: `// 基本的なJavaScriptの例\nfunction calculateTotal(items) {\n  return items\n    .map(item => item.price * item.quantity)\n    .reduce((total, value) => total + value, 0);\n}\n\nconst items = [\n  { name: 'Item 1', price: 100, quantity: 2 },\n  { name: 'Item 2', price: 200, quantity: 1 }\n];\n\nconsole.log(calculateTotal(items));`,\n  typescript: `// 基本的なTypeScriptの例\ninterface Item {\n  name: string;\n  price: number;\n  quantity: number;\n}\n\nfunction calculateTotal(items: Item[]): number {\n  return items\n    .map(item => item.price * item.quantity)\n    .reduce((total, value) => total + value, 0);\n}\n\nconst items: Item[] = [\n  { name: 'Item 1', price: 100, quantity: 2 },\n  { name: 'Item 2', price: 200, quantity: 1 }\n];\n\nconsole.log(calculateTotal(items));`,\n  html: `<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Example Page</title>\n</head>\n<body>\n  <h1>Example Page</h1>\n  <p>This is an example HTML page.</p>\n</body>\n</html>`,\n  css: `/* 基本的なCSSの例 */\nbody {\n  font-family: 'Helvetica Neue', Arial, sans-serif;\n  line-height: 1.6;\n  color: #333;\n  margin: 0;\n  padding: 20px;\n}\n\nh1 {\n  color: #0066cc;\n  border-bottom: 1px solid #eee;\n  padding-bottom: 10px;\n}\n\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n}`,\n  markdown: `# マークダウンの例\n\n## 見出し\n\nこれは**太字**で、これは*イタリック*です。\n\n- リストアイテム1\n- リストアイテム2\n- リストアイテム3\n\n[リンク](https://example.com)\n\n\\`\\`\\`js\n// コードブロック\nfunction hello() {\n  console.log('Hello, world!');\n}\n\\`\\`\\``,\n  plaintext: `これはプレーンテキストの例です。\n特別な書式は適用されません。\n複数行のテキストを入力できます。`\n};\n\n// YAMLプラグイン - Monaco Editorの言語機能に依存\nconst yamlPlugin: LanguagePlugin = {\n  language: 'yaml',\n  validate: (content: string) => {\n    if (!content.trim()) return { isValid: true, markers: [] };\n    \n    // 簡易的なYAML構文チェック（Monacoの言語機能に任せる前の基本検証）\n    const markers: MonacoMarker[] = [];\n    const lines = content.split('\\n');\n    \n    // インデントの整合性チェック（簡易版）\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trimEnd();\n      const lineNumber = i + 1;\n      \n      // コメント行はスキップ\n      if (line.trim().startsWith('#')) continue;\n      \n      // 空行はスキップ\n      if (!line.trim()) continue;\n      \n      // コロンの位置チェック\n      if (line.includes(':')) {\n        const colonIndex = line.indexOf(':');\n        const afterColon = line.substring(colonIndex + 1).trim();\n        \n        // キーの後にコロンがあるが値がなく、次の行がインデントされていない場合\n        if (afterColon === '' && i + 1 < lines.length && \n            !lines[i + 1].startsWith(' ') && lines[i + 1].trim() !== '' && \n            !lines[i + 1].trim().startsWith('-') && !lines[i + 1].trim().startsWith('#')) {\n          markers.push({\n            startLineNumber: lineNumber,\n            startColumn: colonIndex + 1,\n            endLineNumber: lineNumber,\n            endColumn: colonIndex + 2,\n            message: 'YAMLの構造エラー: マップのキーの後にはインデントされた値が必要です',\n            severity: 8 // monaco.MarkerSeverity.Error\n          });\n        }\n      }\n      \n      // リストアイテムの不正な構造をチェック\n      if (line.trim().startsWith('-')) {\n        const dashIndex = line.indexOf('-');\n        if (dashIndex > 0) {\n          const indent = dashIndex;\n          const nextLine = i + 1 < lines.length ? lines[i + 1] : '';\n          \n          if (nextLine.trim() && !nextLine.trim().startsWith('-') && \n              !nextLine.startsWith(' '.repeat(indent + 2)) && !nextLine.trim().startsWith('#')) {\n            markers.push({\n              startLineNumber: lineNumber + 1,\n              startColumn: 1,\n              endLineNumber: lineNumber + 1,\n              endColumn: nextLine.length + 1,\n              message: 'YAMLの構造エラー: リストアイテムの下のコンテンツは正しくインデントする必要があります',\n              severity: 8 // monaco.MarkerSeverity.Error\n            });\n          }\n        }\n      }\n    }\n    \n    if (markers.length > 0) {\n      return {\n        isValid: false,\n        error: 'YAML構文エラー',\n        markers\n      };\n    }\n    \n    return { isValid: true, markers: [] };\n  },\n  setupMonaco: (monaco) => {\n    if (!monaco) return;\n    \n    // Monaco EditorのYAML言語サポートの設定\n    monaco.languages.yaml?.defaults?.setDiagnosticsOptions?.({\n      validate: true,\n      schemas: [],\n      enableSchemaRequest: true,\n      format: true\n    });\n    \n    // エディタのテーマに合わせてYAML言語のハイライト設定を調整\n    const currentTheme = monaco.editor.getTheme();\n    if (currentTheme.includes('light')) {\n      // ライトテーマ向けの設定\n      monaco.editor.defineTheme('yaml-light', {\n        base: 'vs',\n        inherit: true,\n        rules: [],\n        colors: {}\n      });\n    }\n  }\n};\n\n// JSONプラグイン - 標準的なJSON.parseを使用\nconst jsonPlugin: LanguagePlugin = {\n  language: 'json',\n  validate: (content: string) => {\n    if (!content.trim()) return { isValid: true, markers: [] };\n    \n    try {\n      // 標準のJSON.parseを使用\n      JSON.parse(content);\n      return { isValid: true, markers: [] };\n    } catch (e) {\n      const error = e as Error;\n      const errorMessage = `JSON構文エラー: ${error.message}`;\n      \n      // エラー位置の抽出を試みる\n      let position = 0;\n      let lineMatch = error.message.match(/at position (\\d+)/i);\n      if (lineMatch) {\n        position = parseInt(lineMatch[1], 10);\n      } else {\n        // JSONエラーメッセージの形式が異なる場合 (at line X column Y)\n        const lineColMatch = error.message.match(/at line (\\d+) column (\\d+)/i);\n        if (lineColMatch) {\n          const errorLine = parseInt(lineColMatch[1], 10);\n          const errorColumn = parseInt(lineColMatch[2], 10);\n          \n          // 行と列から位置を計算\n          const lines = content.split('\\n');\n          for (let i = 0; i < errorLine - 1; i++) {\n            position += lines[i].length + 1; // +1 for newline\n          }\n          position += errorColumn - 1;\n        }\n      }\n      \n      // 行と列の計算\n      const lines = content.split('\\n');\n      let currentPos = 0;\n      let line = 1;\n      let column = 1;\n      \n      for (let i = 0; i < lines.length; i++) {\n        if (currentPos + lines[i].length + 1 > position) {\n          line = i + 1;\n          column = position - currentPos + 1;\n          break;\n        }\n        currentPos += lines[i].length + 1; // +1 for newline\n      }\n      \n      const markers: MonacoMarker[] = [{\n        startLineNumber: line,\n        startColumn: column,\n        endLineNumber: line,\n        endColumn: column + 1,\n        message: errorMessage,\n        severity: 8 // monaco.MarkerSeverity.Error\n      }];\n      \n      return {\n        isValid: false,\n        error: errorMessage,\n        markers\n      };\n    }\n  },\n  setupMonaco: (monaco) => {\n    if (!monaco) return;\n    \n    // Monaco EditorのJSON言語サポートを設定\n    monaco.languages.json?.defaults?.setDiagnosticsOptions?.({\n      validate: true,\n      allowComments: false,\n      schemas: [],\n      enableSchemaRequest: true\n    });\n    \n    // エディタのテーマに合わせてJSON言語のハイライト設定を調整\n    const currentTheme = monaco.editor.getTheme();\n    if (currentTheme.includes('light')) {\n      // ライトテーマ向けの設定\n      monaco.editor.defineTheme('json-light', {\n        base: 'vs',\n        inherit: true,\n        rules: [],\n        colors: {}\n      });\n    }\n  }\n};\n\n// その他の言語のプラグイン（簡易版）\nconst createSimplePlugin = (language: SupportedLanguage): LanguagePlugin => ({\n  language,\n  validate: () => ({ isValid: true, markers: [] }),\n  setupMonaco: () => {}\n});\n\n// プラグインの登録\nregisterLanguagePlugin(yamlPlugin);\nregisterLanguagePlugin(jsonPlugin);\nregisterLanguagePlugin(createSimplePlugin('javascript'));\nregisterLanguagePlugin(createSimplePlugin('typescript'));\nregisterLanguagePlugin(createSimplePlugin('html'));\nregisterLanguagePlugin(createSimplePlugin('css'));\nregisterLanguagePlugin(createSimplePlugin('markdown'));\nregisterLanguagePlugin(createSimplePlugin('plaintext'));\n\n// 言語名の取得\nexport const getLanguageLabel = (language: SupportedLanguage): string => {\n  const labels: Record<SupportedLanguage, string> = {\n    yaml: 'YAML',\n    json: 'JSON',\n    javascript: 'JavaScript',\n    typescript: 'TypeScript',\n    html: 'HTML',\n    css: 'CSS',\n    markdown: 'Markdown',\n    plaintext: 'プレーンテキスト'\n  };\n  \n  return labels[language] || language;\n};\n\n// 言語のファイル拡張子\nexport const getLanguageExtension = (language: SupportedLanguage): string => {\n  const extensions: Record<SupportedLanguage, string> = {\n    yaml: 'yml',\n    json: 'json',\n    javascript: 'js',\n    typescript: 'ts',\n    html: 'html',\n    css: 'css',\n    markdown: 'md',\n    plaintext: 'txt'\n  };\n  \n  return extensions[language];\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/language-plugins/index.ts",
      "content": "import { registerLanguagePlugin } from '../code-utils';\nimport typescriptPlugin from './typescript-plugin';\nimport htmlPlugin from './html-plugin';\nimport cssPlugin from './css-plugin';\n\n// すべてのプラグインを登録する\nexport function registerAllPlugins() {\n  // TypeScriptプラグインを登録\n  registerLanguagePlugin(typescriptPlugin);\n  \n  // HTMLプラグインを登録\n  registerLanguagePlugin(htmlPlugin);\n  \n  // CSSプラグインを登録\n  registerLanguagePlugin(cssPlugin);\n  \n  // 将来: 他の言語プラグインもここで登録\n  // registerLanguagePlugin(javascriptPlugin);\n  // ...\n}\n\n// 初期化時に呼び出す\nexport function initializeLanguagePlugins() {\n  registerAllPlugins();\n  console.log('言語プラグインの初期化が完了しました');\n}\n\nexport default {\n  registerAllPlugins,\n  initializeLanguagePlugins\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/language-plugins/typescript-plugin.ts",
      "content": "import { LanguagePlugin, MonacoMarker } from '../code-utils';\n\n// TypeScriptの簡易的な構文チェック\nconst validateTypeScript = (content: string): { isValid: boolean; error?: string; markers?: MonacoMarker[] } => {\n  if (!content.trim()) return { isValid: true, markers: [] };\n  \n  const markers: MonacoMarker[] = [];\n  const lines = content.split('\\n');\n  \n  // 簡易的な構文チェック（実際の実装ではTypeScriptコンパイラやESLintが必要）\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineNumber = i + 1;\n    \n    // 未終了のステートメントをチェック\n    if (line.includes('{') && !line.includes('}') && !line.trim().endsWith('{')) {\n      // 単一行に開始括弧はあるが閉じ括弧がない場合（意図的な場合も多いのでマーカーとしては追加しない）\n    }\n    \n    // セミコロンの欠落をチェック（簡易的なチェック）\n    if (line.trim() && \n        !line.trim().endsWith('{') && \n        !line.trim().endsWith('}') && \n        !line.trim().endsWith(';') &&\n        !line.trim().endsWith(',') &&\n        !line.trim().startsWith('//') &&\n        !line.trim().startsWith('import') &&\n        !line.trim().startsWith('export') &&\n        !line.trim().startsWith('function') &&\n        !line.trim().startsWith('interface') &&\n        !line.trim().startsWith('type') &&\n        !line.trim().startsWith('class')) {\n        \n      markers.push({\n        startLineNumber: lineNumber,\n        startColumn: line.length + 1,\n        endLineNumber: lineNumber,\n        endColumn: line.length + 1,\n        message: 'セミコロンが欠落している可能性があります',\n        severity: 4 // monaco.MarkerSeverity.Warning\n      });\n    }\n    \n    // 型の使用法をチェック\n    if (line.includes(':') && !line.includes('?:')) {\n      const parts = line.split(':');\n      if (parts.length > 1) {\n        const typePart = parts[1].trim();\n        \n        // 基本型のスペルミスをチェック\n        const basicTypes = ['string', 'number', 'boolean', 'any', 'void', 'never', 'unknown', 'object'];\n        const typeName = typePart.split(' ')[0].split('|')[0].split('<')[0].trim();\n        \n        if (typeName && \n            !basicTypes.includes(typeName) && \n            !typeName.startsWith('Array') && \n            !typeName.startsWith('[') &&\n            !typeName.startsWith('{') &&\n            !typeName.startsWith('(') &&\n            typeName.length > 0 && \n            typeName[0] === typeName[0].toLowerCase() && \n            basicTypes.some(t => {\n              const distance = levenshteinDistance(t, typeName);\n              return distance > 0 && distance <= 2; // 2文字以内の編集距離\n            })) {\n          \n          const typeIndex = line.indexOf(':') + 1;\n          const typeStart = typeIndex + line.substring(typeIndex).indexOf(typeName);\n          \n          markers.push({\n            startLineNumber: lineNumber,\n            startColumn: typeStart + 1,\n            endLineNumber: lineNumber,\n            endColumn: typeStart + typeName.length + 1,\n            message: '型名のスペルミスの可能性があります',\n            severity: 4 // monaco.MarkerSeverity.Warning\n          });\n        }\n      }\n    }\n  }\n  \n  return {\n    isValid: true, // 警告のみなのでバリデーションは通す\n    markers\n  };\n};\n\n// レーベンシュタイン距離（編集距離）を計算する関数\nfunction levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n  \n  // 行列の初期化\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n  \n  for (let j = 0; j <= a.length; j++) {\n    matrix[0][j] = j;\n  }\n  \n  // 距離の計算\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1, // 置換\n          matrix[i][j - 1] + 1,     // 挿入\n          matrix[i - 1][j] + 1      // 削除\n        );\n      }\n    }\n  }\n  \n  return matrix[b.length][a.length];\n}\n\n// MonacoエディタへのTypeScript言語の設定\nconst setupTypeScriptMonaco = (monaco: any) => {\n  if (!monaco) return;\n  \n  // TypeScriptの設定\n  monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n    noSemanticValidation: false,\n    noSyntaxValidation: false\n  });\n  \n  // コンパイラオプションの設定\n  monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n    target: monaco.languages.typescript.ScriptTarget.ES2015,\n    allowNonTsExtensions: true,\n    moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n    module: monaco.languages.typescript.ModuleKind.CommonJS,\n    noEmit: true,\n    typeRoots: [\"node_modules/@types\"]\n  });\n};\n\n// TypeScriptプラグインのエクスポート\nconst typescriptPlugin: LanguagePlugin = {\n  language: 'typescript',\n  validate: validateTypeScript,\n  setupMonaco: setupTypeScriptMonaco\n};\n\nexport default typescriptPlugin; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/language-plugins/html-plugin.ts",
      "content": "import { LanguagePlugin, MonacoMarker } from '../code-utils';\n\n// HTMLの簡易的な構文チェック\nconst validateHTML = (content: string): { isValid: boolean; error?: string; markers?: MonacoMarker[] } => {\n  if (!content.trim()) return { isValid: true, markers: [] };\n  \n  const markers: MonacoMarker[] = [];\n  const lines = content.split('\\n');\n  \n  // タグの開始と終了をチェック\n  const openTags: { tag: string; line: number; column: number }[] = [];\n  const selfClosingTags = ['img', 'br', 'hr', 'input', 'meta', 'link', 'area', 'base', 'col', 'embed', 'keygen', 'param', 'source', 'track', 'wbr'];\n  \n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineNumber = i + 1;\n    \n    // 開始タグと終了タグを検出\n    let pos = 0;\n    while (pos < line.length) {\n      const openIndex = line.indexOf('<', pos);\n      if (openIndex === -1) break;\n      \n      const closeIndex = line.indexOf('>', openIndex);\n      if (closeIndex === -1) {\n        // 終了タグがない\n        markers.push({\n          startLineNumber: lineNumber,\n          startColumn: openIndex + 1,\n          endLineNumber: lineNumber,\n          endColumn: openIndex + 2,\n          message: 'タグが閉じられていません',\n          severity: 8 // monaco.MarkerSeverity.Error\n        });\n        break;\n      }\n      \n      const tagContent = line.substring(openIndex + 1, closeIndex);\n      \n      if (tagContent.startsWith('/')) {\n        // 終了タグ\n        const tagName = tagContent.substring(1).trim().split(' ')[0];\n        \n        if (openTags.length === 0) {\n          // 対応する開始タグがない\n          markers.push({\n            startLineNumber: lineNumber,\n            startColumn: openIndex + 1,\n            endLineNumber: lineNumber,\n            endColumn: closeIndex + 1,\n            message: `\"${tagName}\"タグに対応する開始タグが見つかりません`,\n            severity: 8 // monaco.MarkerSeverity.Error\n          });\n        } else {\n          const lastOpenTag = openTags.pop();\n          if (lastOpenTag && lastOpenTag.tag !== tagName) {\n            // タグの不一致\n            markers.push({\n              startLineNumber: lineNumber,\n              startColumn: openIndex + 1,\n              endLineNumber: lineNumber,\n              endColumn: closeIndex + 1,\n              message: `\"${tagName}\"タグが\"${lastOpenTag.tag}\"タグと一致しません`,\n              severity: 8 // monaco.MarkerSeverity.Error\n            });\n            // 開始タグを戻す\n            openTags.push(lastOpenTag);\n          }\n        }\n      } else if (!tagContent.endsWith('/') && !tagContent.startsWith('!') && !tagContent.startsWith('?')) {\n        // 開始タグ（自己終了タグでない場合）\n        const tagName = tagContent.trim().split(' ')[0];\n        \n        if (!selfClosingTags.includes(tagName.toLowerCase())) {\n          openTags.push({\n            tag: tagName,\n            line: lineNumber,\n            column: openIndex + 1\n          });\n        }\n      }\n      \n      pos = closeIndex + 1;\n    }\n  }\n  \n  // 閉じられていないタグをチェック\n  for (const openTag of openTags) {\n    markers.push({\n      startLineNumber: openTag.line,\n      startColumn: openTag.column,\n      endLineNumber: openTag.line,\n      endColumn: openTag.column + openTag.tag.length + 1,\n      message: `\"${openTag.tag}\"タグが閉じられていません`,\n      severity: 8 // monaco.MarkerSeverity.Error\n    });\n  }\n  \n  // マーカーがあればエラーとする\n  const hasErrors = markers.length > 0;\n  \n  return {\n    isValid: !hasErrors,\n    error: hasErrors ? 'HTML構文エラーがあります' : undefined,\n    markers\n  };\n};\n\n// MonacoエディタへのHTML言語の設定\nconst setupHTMLMonaco = (monaco: any) => {\n  if (!monaco) return;\n  \n  // HTML言語の設定\n  monaco.languages.html?.defaults?.setDiagnosticsOptions?.({\n    validate: true,\n  });\n};\n\n// HTMLプラグインのエクスポート\nconst htmlPlugin: LanguagePlugin = {\n  language: 'html',\n  validate: validateHTML,\n  setupMonaco: setupHTMLMonaco\n};\n\nexport default htmlPlugin; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/language-plugins/css-plugin.ts",
      "content": "import { LanguagePlugin, MonacoMarker } from '../code-utils';\n\n// CSSの簡易的な構文チェック\nconst validateCSS = (content: string): { isValid: boolean; error?: string; markers?: MonacoMarker[] } => {\n  if (!content.trim()) return { isValid: true, markers: [] };\n  \n  const markers: MonacoMarker[] = [];\n  const lines = content.split('\\n');\n  \n  // 簡易的な構文チェック\n  let isInBlock = false;\n  let blockStartLine = 0;\n  let openBraces = 0;\n  \n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineNumber = i + 1;\n    \n    // コメント行はスキップ（簡易判定）\n    if (line.trim().startsWith('/*') || line.trim().startsWith('*') || line.trim().startsWith('*/')) continue;\n    if (line.trim().startsWith('//')) continue;\n    \n    // 空行はスキップ\n    if (!line.trim()) continue;\n    \n    // 波括弧のカウント\n    for (let j = 0; j < line.length; j++) {\n      if (line[j] === '{') {\n        if (!isInBlock) {\n          isInBlock = true;\n          blockStartLine = lineNumber;\n        }\n        openBraces++;\n      } else if (line[j] === '}') {\n        openBraces--;\n        if (openBraces === 0) {\n          isInBlock = false;\n        } else if (openBraces < 0) {\n          markers.push({\n            startLineNumber: lineNumber,\n            startColumn: j + 1,\n            endLineNumber: lineNumber,\n            endColumn: j + 2,\n            message: '閉じ括弧が多すぎます',\n            severity: 8 // monaco.MarkerSeverity.Error\n          });\n          openBraces = 0; // リセット\n        }\n      }\n    }\n    \n    // セミコロンの欠落をチェック\n    if (isInBlock && !line.includes('{') && !line.includes('}') && line.trim() && !line.trim().endsWith(';')) {\n      markers.push({\n        startLineNumber: lineNumber,\n        startColumn: line.length + 1,\n        endLineNumber: lineNumber,\n        endColumn: line.length + 1,\n        message: 'セミコロンが欠落している可能性があります',\n        severity: 4 // monaco.MarkerSeverity.Warning\n      });\n    }\n    \n    // プロパティ定義のチェック\n    if (isInBlock && line.includes(':')) {\n      const colonIndex = line.indexOf(':');\n      // コロンの前後にスペースがあるかチェック（スタイルガイド）\n      if (colonIndex > 0 && line[colonIndex - 1] === ' ') {\n        markers.push({\n          startLineNumber: lineNumber,\n          startColumn: colonIndex,\n          endLineNumber: lineNumber,\n          endColumn: colonIndex + 1,\n          message: 'コロンの前にスペースを入れるべきではありません',\n          severity: 4 // monaco.MarkerSeverity.Warning\n        });\n      }\n      \n      // 値がない場合\n      if (colonIndex === line.trim().length - 1) {\n        markers.push({\n          startLineNumber: lineNumber,\n          startColumn: colonIndex + 1,\n          endLineNumber: lineNumber,\n          endColumn: colonIndex + 2,\n          message: 'プロパティに値が指定されていません',\n          severity: 8 // monaco.MarkerSeverity.Error\n        });\n      }\n    }\n  }\n  \n  // 閉じられていないブロックをチェック\n  if (openBraces > 0) {\n    markers.push({\n      startLineNumber: blockStartLine,\n      startColumn: 1,\n      endLineNumber: blockStartLine,\n      endColumn: lines[blockStartLine - 1].length + 1,\n      message: `${openBraces}個の閉じ括弧が不足しています`,\n      severity: 8 // monaco.MarkerSeverity.Error\n    });\n  }\n  \n  return {\n    isValid: !markers.some(marker => marker.severity === 8), // エラーがある場合のみ無効\n    error: markers.some(marker => marker.severity === 8) ? 'CSS構文エラーがあります' : undefined,\n    markers\n  };\n};\n\n// MonacoエディタへのCSS言語の設定\nconst setupCSSMonaco = (monaco: any) => {\n  if (!monaco) return;\n  \n  // CSS言語の設定\n  monaco.languages.css?.defaults?.setDiagnosticsOptions?.({\n    validate: true,\n    lint: {\n      compatibleVendorPrefixes: 'warning',\n      vendorPrefix: 'warning',\n      duplicateProperties: 'warning',\n      emptyRules: 'warning',\n      importStatement: 'warning',\n      boxModel: 'warning',\n      universalSelector: 'warning',\n      zeroUnits: 'warning',\n      fontFaceProperties: 'warning',\n      hexColorLength: 'warning',\n      argumentsInColorFunction: 'warning',\n      unknownProperties: 'warning',\n      ieHack: 'warning',\n      unknownVendorSpecificProperties: 'warning',\n      propertyIgnoredDueToDisplay: 'warning',\n      important: 'warning',\n      float: 'warning'\n    }\n  });\n};\n\n// CSSプラグインのエクスポート\nconst cssPlugin: LanguagePlugin = {\n  language: 'css',\n  validate: validateCSS,\n  setupMonaco: setupCSSMonaco\n};\n\nexport default cssPlugin; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/en.json",
      "content": "{\n  \"components\": {\n    \"resource-form\": {\n      \"created-success\": \"Resource created successfully\",\n      \"updated-success\": \"Resource updated successfully\",\n      \"created-error\": \"An error occurred while creating the resource\",\n      \"updated-error\": \"An error occurred while updating the resource\",\n      \"fetch-error\": \"Failed to fetch resource\",\n      \"cancel\": \"Cancel\",\n      \"creating\": \"Creating...\",\n      \"updating\": \"Updating...\",\n      \"create\": \"Create\",\n      \"update\": \"Update\",\n      \"prev\": \"Previous\",\n      \"next\": \"Next\",\n      \"step\": \"Step\",\n      \"need\": \"{label} is required\",\n      \"textlesser\": \"{label} must be {maxLength} characters or less\",\n      \"number\": \"Please enter a number\",\n      \"greater\": \"{label} must be greater than or equal to {min}\",\n      \"lesser\": \"{label} must be less than or equal to {max}\",\n      \"select\": \"Select {label}\",\n      \"add\": \"Add\",\n      \"unit\": \"Please select a unit\",\n      \"error\": \"An error occurred\",\n      \"loading\": \"Loading resource data...\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/en.json"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/ja.json",
      "content": "{\n  \"components\": {\n    \"resource-form\": {\n      \"created-success\": \"リソースが作成されました\",\n      \"updated-success\": \"リソースが更新されました\",\n      \"created-error\": \"リソースの作成中にエラーが発生しました\",\n      \"updated-error\": \"リソースの更新中にエラーが発生しました\",\n      \"fetch-error\": \"リソースの取得に失敗しました\",\n      \"cancel\": \"キャンセル\",\n      \"creating\": \"作成中...\",\n      \"updating\": \"更新中...\",\n      \"create\": \"作成\",\n      \"update\": \"更新\",\n      \"prev\": \"前へ\",\n      \"next\": \"次へ\",\n      \"step\": \"ステップ\",\n      \"need\": \"{label}は必須項目です\",\n      \"textlesser\": \"{label}は{maxLength}文字以内で入力してください\",\n      \"number\": \"数値を入力してください\",\n      \"greater\": \"{label}は{min}以上の値を入力してください\",\n      \"lesser\": \"{label}は{max}以下の値を入力してください\",\n      \"select\": \"{label}を選択\",\n      \"add\": \"追加\",\n      \"unit\": \"単位を選択してください\",\n      \"error\": \"エラーが発生しました\",\n      \"loading\": \"リソースデータを読み込み中...\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/ja.json"
    }
  ]
}