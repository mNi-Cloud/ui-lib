{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "resource-form",
  "type": "registry:component",
  "title": "Resource Form",
  "description": "A resource create/edit form component.",
  "dependencies": [
    "next-intl",
    "@hookform/resolvers",
    "react-hook-form",
    "sonner",
    "zod"
  ],
  "registryDependencies": [
    "form",
    "card",
    "input",
    "select",
    "button",
    "alert",
    "progress",
    "textarea",
    "sonner",
    "alert",
    "https://raw.github.com/mNi-Cloud/ui-lib/main/public/r/actions.json",
    "https://raw.github.com/mNi-Cloud/ui-lib/main/public/r/code-editor.json"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/resource-form/resource-form.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { useForm, UseFormReturn } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { toast } from 'sonner';\nimport { useTranslations } from 'next-intl';\nimport { Card, CardContent } from '@/registry/new-york/ui/card';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { Form } from '@/registry/new-york/ui/form';\nimport { Alert, AlertDescription } from '@/registry/new-york/ui/alert';\nimport { AlertCircle } from 'lucide-react';\nimport { CommonFieldDefinition, StepDefinition } from './resource-form-utils';\nimport { generateSchema, generateDefaultValues } from './schema-generator';\nimport FieldRenderer from './field-renderer';\nimport CodeEditor from '@/registry/new-york/blocks/code-editor/code-editor';\nimport { createResource, updateResource, fetchResource } from '@/registry/new-york/blocks/actions/resource-actions';\n\n// シンプルなバリデータ関数を提供\nconst getValidator = () => {\n  // 全ての言語に対して単純なバリデータを返す\n  return (content: string) => ({ isValid: true });\n};\n\n// フォーム型の拡張\ninterface ExtendedFormProps extends UseFormReturn<any, any, any> {\n  _syntaxErrors?: Record<string, boolean>;\n}\n\n// 単一ステップフォーム用の型定義\nexport type ResourceFormProps = {\n  title: string;\n  resourceType: string;\n  fields: CommonFieldDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: any) => any;\n  defaultValues?: Record<string, any>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\n// 複数ステップフォーム用の型定義\nexport type MultiStepResourceFormProps = {\n  title: string;\n  resourceType: string;\n  steps: StepDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: any) => any;\n  defaultValues?: Record<string, any>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\n/**\n * リソース作成・編集フォーム\n */\nexport const ResourceForm: React.FC<ResourceFormProps> = ({\n  title,\n  resourceType,\n  fields,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  formatFormData,\n  defaultValues = {},\n  resourceId,\n  isEditMode = false\n}) => {\n  const router = useRouter();\n  const t = useTranslations('components.resource-form');\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [syntaxError, setSyntaxError] = useState<string | null>(null);\n\n  // 安全にフィールドを処理\n  const safeFields = Array.isArray(fields) ? fields : [];\n\n  // フォームスキーマの生成\n  const formSchema = generateSchema(safeFields, t, getValidator);\n\n  // react-hook-formの設定\n  const form = useForm<z.infer<typeof formSchema>>({\n    resolver: zodResolver(formSchema),\n    defaultValues: generateDefaultValues(safeFields, defaultValues),\n  }) as ExtendedFormProps;\n\n  // 構文エラーチェック関数\n  const checkSyntaxErrors = (): boolean => {\n    if (form._syntaxErrors) {\n      // いずれかのフィールドに構文エラーがあるかチェック\n      const hasErrors = Object.entries(form._syntaxErrors).some(([fieldName, hasError]) => hasError === true);\n      if (hasErrors) {\n        // エラーのあるフィールド名を抽出\n        const errorFields = Object.entries(form._syntaxErrors)\n          .filter(([_, hasError]) => hasError === true)\n          .map(([fieldName, _]) => {\n            // フィールド名からラベルを取得\n            const field = safeFields.find(f => f.name === fieldName);\n            return field ? field.label : fieldName;\n          });\n        \n        // エラーメッセージを設定\n        setSyntaxError(t('syntax-error-message'));\n        return true;\n      }\n    }\n    \n    setSyntaxError(null);\n    return false;\n  };\n\n  // リソースの取得（編集モードの場合）\n  useEffect(() => {\n    if (isEditMode && resourceId) {\n      const getResource = async () => {\n        try {\n          const data = await fetchResource(apiEndpoint, resourceId);\n          if (data) {\n            // データを各フィールドにセット\n            Object.entries(data).forEach(([key, value]) => {\n              // ネストされたオブジェクトも処理\n              if (typeof value === 'object' && value !== null) {\n                form.setValue(key, value);\n              } else {\n                form.setValue(key, value);\n              }\n            });\n          }\n        } catch (error) {\n          console.error('Failed to fetch resource:', error);\n          setError(t('fetch-error'));\n        }\n      };\n\n      getResource();\n    }\n  }, [isEditMode, resourceId, apiEndpoint, form, t]);\n\n  // フォーム送信処理\n  const onSubmit = async (data: z.infer<typeof formSchema>) => {\n    // 送信前に構文エラーをチェック\n    if (checkSyntaxErrors()) {\n      return; // 構文エラーがある場合は処理を中止\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      // 送信前のデータ整形\n      const formattedData = formatFormData ? formatFormData(data) : data;\n\n      // リソースの作成または更新\n      let result;\n      if (isEditMode && resourceId) {\n        result = await updateResource(apiEndpoint, resourceId, {\n          type: resourceType,\n          data: formattedData,\n        });\n      } else {\n        result = await createResource(apiEndpoint, {\n          type: resourceType,\n          data: formattedData,\n        });\n      }\n\n      // 成功時の処理\n      if (result) {\n        toast.success(\n          successMessage || (isEditMode ? t('updated-success') : t('created-success')), \n          { id: 'resource-action' }\n        );\n        router.push(redirectPath);\n      }\n    } catch (e) {\n      console.error('Form submission error:', e);\n      setError(errorMessage || (isEditMode ? t('updated-error') : t('created-error')));\n      toast.error(\n        errorMessage || (isEditMode ? t('updated-error') : t('created-error')), \n        { id: 'resource-action' }\n      );\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // キャンセルボタンのハンドラー\n  const onCancel = () => {\n    router.push(redirectPath);\n  };\n\n  return (\n    <Card>\n      <CardContent className=\"p-6\">\n        <div className=\"space-y-6\">\n          <div>\n            <h1 className=\"text-2xl font-semibold mb-2\">{title}</h1>\n          </div>\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n              {safeFields.map(field => (\n                <FieldRenderer \n                  key={`field-${field.name}`}\n                  field={field} \n                  form={form}\n                  translationNamespace=\"components.resource-form\"\n                  codeEditor={CodeEditor}\n                />\n              ))}\n              \n              {syntaxError && (\n                <Alert variant=\"destructive\" className=\"mt-4\">\n                  <AlertCircle className=\"h-4 w-4\" />\n                  <AlertDescription>\n                    {syntaxError}\n                  </AlertDescription>\n                </Alert>\n              )}\n              \n              <div className=\"flex justify-end gap-2\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={onCancel}\n                >\n                  {t('cancel')}\n                </Button>\n                <Button\n                  type=\"submit\"\n                  disabled={loading}\n                >\n                  {loading ? (\n                    <div className=\"flex items-center\">\n                      <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n                      {isEditMode ? t('updating') : t('creating')}\n                    </div>\n                  ) : (\n                    isEditMode ? t('update') : t('create')\n                  )}\n                </Button>\n              </div>\n            </form>\n          </Form>\n        </div>\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default ResourceForm; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/field-renderer.tsx",
      "content": "'use client';\n\nimport React from 'react';\nimport { useFieldArray, UseFormReturn } from 'react-hook-form';\nimport { Input } from '@/registry/new-york/ui/input';\nimport { Textarea } from '@/registry/new-york/ui/textarea';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/registry/new-york/ui/select';\nimport {\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n  FormDescription,\n} from '@/registry/new-york/ui/form';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { X } from 'lucide-react';\nimport { useTranslations } from 'next-intl';\nimport { \n  CommonFieldDefinition, \n} from './resource-form-utils';\nimport { SupportedLanguage } from '@/registry/new-york/blocks/code-editor/code-editor';\n\n// フォーム型の拡張\ninterface ExtendedFormProps extends UseFormReturn<any, any, any> {\n  _syntaxErrors?: Record<string, boolean>;\n}\n\n// シンプルなバリデータ関数を提供\nconst getValidator = (language: SupportedLanguage) => {\n  // 全ての言語に対して単純なバリデータを返す\n  return (content: string) => ({ isValid: true });\n};\n\ninterface ArrayItemRecord {\n  [key: string]: string;\n}\n\ntype FieldRendererProps = {\n  field: CommonFieldDefinition;\n  form: ExtendedFormProps;\n  fieldNamePrefix?: string;\n  translationNamespace?: string;\n  codeEditor?: React.ComponentType<{\n    value: string;\n    onChange: (value: string) => void;\n    language?: SupportedLanguage;\n    height?: string;\n    placeholder?: string;\n    disabled?: boolean;\n    readOnly?: boolean;\n    showValidation?: boolean;\n    validator?: (content: string) => { isValid: boolean; error?: string };\n    theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light';\n    onValidationChange?: (hasErrors: boolean) => void;\n  }>;\n};\n\nexport const FieldRenderer: React.FC<FieldRendererProps> = ({\n  field,\n  form,\n  fieldNamePrefix = '',\n  translationNamespace = 'components.resource-create',\n  codeEditor: CodeEditor\n}) => {\n  const t = useTranslations(translationNamespace);\n  const fieldName = fieldNamePrefix ? `${fieldNamePrefix}.${field.name}` : field.name;\n\n  // readOnlyメッセージの表示\n  const renderReadOnlyMessage = () => {\n    if (field.readOnly && field.readOnlyMessage) {\n      return (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      );\n    }\n    return null;\n  };\n\n  // カスタムコンポーネントの処理\n  if (field.type === 'custom' && field.render) {\n    return (\n      <div key={`form-field-${fieldName}`}>\n        {field.render({ \n          values: form.getValues(), \n          form \n        })}\n      </div>\n    );\n  }\n\n  // ユニット入力の処理\n  if (field.type === 'unit-input') {\n    return (\n      <div key={`form-field-${fieldName}`} className=\"space-y-2\">\n        <div className=\"space-y-1\">\n          <FormLabel className=\"text-sm font-medium\">\n            {field.label}\n            {field.validation?.required && (\n              <span className=\"text-destructive ml-1\">*</span>\n            )}\n          </FormLabel>\n          {field.description && (\n            <FormDescription className=\"text-xs\">\n              {field.description}\n            </FormDescription>\n          )}\n          {renderReadOnlyMessage()}\n        </div>\n\n        <div className=\"flex flex-col md:flex-row gap-2 w-full\">\n          <div className=\"flex-grow\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Value`}\n              render={({ field: formField }) => (\n                <FormControl>\n                  <Input\n                    type=\"number\"\n                    placeholder={field.placeholder}\n                    className={field.readOnly ? 'bg-muted' : 'h-10'}\n                    value={formField.value}\n                    onChange={(e) => {\n                      formField.onChange(e);\n                      const unit = form.getValues(`${fieldName}Unit`);\n                      form.setValue(fieldName, `${e.target.value}${unit}`);\n                    }}\n                    readOnly={field.readOnly}\n                  />\n                </FormControl>\n              )}\n            />\n          </div>\n\n          <div className=\"w-full md:w-[160px]\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Unit`}\n              render={({ field: formField }) => (\n                <Select\n                  value={formField.value}\n                  defaultValue={field.defaultUnit}\n                  onValueChange={(value) => {\n                    formField.onChange(value);\n                    const numValue = form.getValues(`${fieldName}Value`);\n                    form.setValue(fieldName, `${numValue}${value}`);\n                  }}\n                  disabled={field.disabled || field.readOnly}\n                >\n                  <FormControl>\n                    <SelectTrigger className={field.readOnly ? 'bg-muted h-10' : 'h-10'}>\n                      <SelectValue />\n                    </SelectTrigger>\n                  </FormControl>\n                  <SelectContent>\n                    {field.units?.map((unit) => (\n                      <SelectItem\n                        key={`${fieldName}-unit-${unit.value}`}\n                        value={unit.value}\n                      >\n                        {unit.label}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              )}\n            />\n          </div>\n        </div>\n        <FormMessage className=\"text-xs\" />\n      </div>\n    );\n  }\n\n  // コードエディタの処理\n  if (field.type === 'code' && CodeEditor) {\n    const language = (field.language || 'plaintext') as SupportedLanguage;\n    const validator = getValidator(language);\n\n    return (\n      <FormField\n        key={`form-field-${fieldName}`}\n        control={form.control}\n        name={fieldName}\n        render={({ field: formField }) => (\n          <FormItem className=\"space-y-2\">\n            <div className=\"space-y-1\">\n              <FormLabel className=\"text-sm font-medium\">\n                {field.label}\n                {field.validation?.required && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n              </FormLabel>\n              {field.description && (\n                <FormDescription className=\"text-xs\">\n                  {field.description}\n                </FormDescription>\n              )}\n              {renderReadOnlyMessage()}\n            </div>\n            <FormControl>\n              <CodeEditor\n                value={formField.value}\n                onChange={(value: string) => {\n                  if (!field.readOnly) {\n                    formField.onChange(value);\n                    field.onChange?.(value);\n                  }\n                }}\n                language={language}\n                readOnly={field.readOnly}\n                height={field.height || '300px'}\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                showValidation={field.validation?.codeValidation !== false}\n                validator={validator}\n                theme={field.theme || 'vs-dark'}\n                onValidationChange={(hasErrors) => {\n                  // フォームのコンテキストにエラー状態を保存\n                  if (form._syntaxErrors) {\n                    form._syntaxErrors[fieldName] = hasErrors;\n                  } else {\n                    form._syntaxErrors = { [fieldName]: hasErrors };\n                  }\n                }}\n              />\n            </FormControl>\n            <FormMessage className=\"text-xs\" />\n          </FormItem>\n        )}\n      />\n    );\n  }\n\n  // 配列フィールドの処理\n  if (field.type === 'array') {\n    return <ArrayFieldRenderer field={field} form={form} fieldName={fieldName} t={t} />;\n  }\n\n  // 一般的なフィールドの処理（テキスト、数値、メール、パスワード、セレクト、テキストエリア）\n  return (\n    <FormField\n      key={`form-field-${fieldName}`}\n      control={form.control}\n      name={fieldName}\n      render={({ field: formField }) => (\n        <FormItem className=\"space-y-2\">\n          <div className=\"space-y-1\">\n            <FormLabel className=\"text-sm font-medium\">\n              {field.label}\n              {field.validation?.required && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n            </FormLabel>\n            {field.description && (\n              <FormDescription className=\"text-xs\">\n                {field.description}\n              </FormDescription>\n            )}\n            {renderReadOnlyMessage()}\n          </div>\n          <FormControl>\n            {field.type === 'select' ? (\n              <Select\n                value={formField.value || ''}\n                onValueChange={(value) => {\n                  if (!field.readOnly) {\n                    formField.onChange(value);\n                    field.onChange?.(value);\n                  }\n                }}\n                disabled={field.disabled || field.readOnly}\n              >\n                <SelectTrigger className={field.readOnly ? 'bg-muted h-10' : 'h-10'}>\n                  <SelectValue placeholder={field.placeholder} />\n                </SelectTrigger>\n                <SelectContent>\n                  {field.options?.map((option) => (\n                    <SelectItem\n                      key={`${fieldName}-option-${option.value}`}\n                      value={option.value}\n                    >\n                      {option.label}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            ) : field.type === 'textarea' ? (\n              <Textarea\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                readOnly={field.readOnly}\n                className={field.readOnly ? 'bg-muted' : ''}\n                {...formField}\n                onChange={(e) => {\n                  if (!field.readOnly) {\n                    formField.onChange(e);\n                    field.onChange?.(e.target.value);\n                  }\n                }}\n              />\n            ) : (\n              <Input\n                type={field.type}\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                readOnly={field.readOnly}\n                className={field.readOnly ? 'bg-muted' : ''}\n                {...formField}\n                onChange={(e) => {\n                  if (!field.readOnly) {\n                    formField.onChange(e);\n                    field.onChange?.(e.target.value);\n                  }\n                }}\n              />\n            )}\n          </FormControl>\n          <FormMessage className=\"text-xs\" />\n        </FormItem>\n      )}\n    />\n  );\n};\n\n// 配列フィールドのレンダリングを処理する内部コンポーネント\nconst ArrayFieldRenderer: React.FC<{\n  field: CommonFieldDefinition;\n  form: ExtendedFormProps;\n  fieldName: string;\n  t: (key: string, params?: any) => string;\n}> = ({ field, form, fieldName, t }) => {\n  const { fields, append, remove } = useFieldArray({\n    control: form.control,\n    name: fieldName,\n  });\n\n  const addNewItem = () => {\n    if (field.readOnly) return;\n\n    if (field.itemType === 'object' && field.fields) {\n      const newItem = field.fields.reduce<Record<string, any>>((acc, fieldItem) => {\n        acc[fieldItem.name] = fieldItem.type === 'number' ? null : '';\n        return acc;\n      }, {});\n      append(newItem);\n    } else {\n      append('');\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <FormLabel>\n          {field.label}\n          {field.validation?.required && (\n            <span className=\"text-destructive ml-1\">*</span>\n          )}\n        </FormLabel>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={addNewItem}\n          disabled={field.readOnly}\n        >\n          {t('add')}\n        </Button>\n      </div>\n      {field.description && (\n        <FormDescription className=\"text-xs\">\n          {field.description}\n        </FormDescription>\n      )}\n      {field.readOnly && field.readOnlyMessage && (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      )}\n\n      {fields.map((arrayField, index) => (\n        <div key={arrayField.id} className=\"relative\">\n          {field.itemType === 'object' ? (\n            <div className=\"flex gap-4 items-start\">\n              {field.fields?.map((subField) => (\n                <FormField\n                  key={`${arrayField.id}-${subField.name}`}\n                  control={form.control}\n                  name={`${fieldName}.${index}.${subField.name}`}\n                  render={({ field: formField }) => (\n                    <FormItem className=\"flex-1\">\n                      <FormLabel>{subField.label}</FormLabel>\n                      <FormControl>\n                        {subField.type === 'select' ? (\n                          <Select\n                            value={formField.value?.toString() || ''}\n                            onValueChange={(value) => {\n                              if (!field.readOnly) {\n                                formField.onChange(value);\n                                if (subField.onChange) {\n                                  subField.onChange(value);\n                                }\n                              }\n                            }}\n                            disabled={subField.disabled || field.readOnly}\n                          >\n                            <SelectTrigger className={field.readOnly ? 'bg-muted' : ''}>\n                              <SelectValue\n                                placeholder={subField.placeholder || t('select', { label: subField.label })}\n                              />\n                            </SelectTrigger>\n                            <SelectContent>\n                              {subField.options?.map((option) => (\n                                <SelectItem\n                                  key={`${subField.name}-${index}-option-${option.value}`}\n                                  value={option.value}\n                                >\n                                  {option.label}\n                                </SelectItem>\n                              ))}\n                            </SelectContent>\n                          </Select>\n                        ) : (\n                          <Input\n                            type={subField.type}\n                            placeholder={subField.placeholder}\n                            className={field.readOnly ? 'bg-muted' : ''}\n                            disabled={subField.disabled || field.readOnly}\n                            readOnly={field.readOnly}\n                            value={formField.value ?? ''}\n                            onChange={(e) => {\n                              if (!field.readOnly) {\n                                const value = subField.type === 'number'\n                                  ? e.target.value === '' ? null : Number(e.target.value)\n                                  : e.target.value;\n                                formField.onChange(value);\n                                if (subField.onChange) {\n                                  subField.onChange(value);\n                                }\n                              }\n                            }}\n                          />\n                        )}\n                      </FormControl>\n                      <FormMessage />\n                      {subField.description && (\n                        <FormDescription>{subField.description}</FormDescription>\n                      )}\n                    </FormItem>\n                  )}\n                />\n              ))}\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"mt-8\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          ) : (\n            <div className=\"flex gap-2\">\n              <FormField\n                control={form.control}\n                name={`${fieldName}.${index}`}\n                render={({ field: formField }) => (\n                  <FormItem className=\"flex-1\">\n                    <FormControl>\n                      <Input\n                        className={field.readOnly ? 'bg-muted' : ''}\n                        readOnly={field.readOnly}\n                        disabled={field.readOnly}\n                        {...formField}\n                        onChange={(e) => {\n                          if (!field.readOnly) {\n                            formField.onChange(e);\n                          }\n                        }}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default FieldRenderer; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/resource-form-utils.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\nimport { SupportedLanguage } from '@/registry/new-york/blocks/code-editor/code-editor';\n\n/**\n * 共通の型定義\n */\nexport type SelectOption = {\n  value: string;\n  label: string;\n};\n\nexport type UnitOption = SelectOption;\n\nexport type ValidationPattern = {\n  value: string;\n  flags?: string;\n  message: string;\n};\n\nexport type BaseFieldValidation = {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: ValidationPattern;\n  codeValidation?: boolean;\n};\n\nexport type BaseFieldDefinition = {\n  name: string;\n  label: string;\n  placeholder?: string;\n  description?: string;\n  validation?: BaseFieldValidation;\n  disabled?: boolean;\n  onChange?: (value: any) => void;\n  defaultValue?: string | number;\n  readOnly?: boolean;\n  readOnlyMessage?: string;\n};\n\n/**\n * すべてのフィールドタイプの共通定義\n */\nexport type CommonFieldType = \n  'text' | 'number' | 'email' | 'password' | 'select' | \n  'array' | 'unit-input' | 'textarea' | 'yaml' | 'custom' | 'code';\n\nexport type CommonFieldObjectDefinition = Omit<BaseFieldDefinition, 'onChange'> & {\n  type: 'text' | 'number' | 'email' | 'password' | 'select';\n  options?: SelectOption[];\n  onChange?: (value: any) => void;\n};\n\nexport type CommonFieldDefinition = BaseFieldDefinition & {\n  type: CommonFieldType;\n  // 各タイプに必要な追加プロパティ\n  options?: SelectOption[];         // select用\n  units?: UnitOption[];             // unit-input用\n  defaultUnit?: string;             // unit-input用\n  itemType?: 'text' | 'object';     // array+object用\n  fields?: CommonFieldObjectDefinition[]; // array+object用\n  render?: (props: { values: any; form: any }) => React.ReactNode; // custom用\n  language?: SupportedLanguage;     // code用\n  height?: string;                  // code用\n  theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light'; // code用\n};\n\n/**\n * 複数ステップフォーム用の定義\n */\nexport type StepDefinition = {\n  id: string;\n  title: string;\n  description?: string;\n  fields: CommonFieldDefinition[];\n};\n\n/**\n * 共通のスキーマ生成関数\n */\nexport const generateFieldSchema = (\n  field: {\n    name: string;\n    label: string;\n    type?: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, any>) => string\n) => {\n  let fieldSchema = z.string();\n\n  if (field.validation) {\n    if (field.validation.required) {\n      fieldSchema = fieldSchema.min(1, t('need', { label: field.label }));\n    }\n\n    if (field.validation.maxLength) {\n      fieldSchema = fieldSchema.max(\n        field.validation.maxLength,\n        t('textlesser', { label: field.label, maxLength: field.validation.maxLength })\n      );\n    }\n\n    if (field.validation.pattern) {\n      const regex = new RegExp(\n        field.validation.pattern.value,\n        field.validation.pattern.flags\n      );\n      fieldSchema = fieldSchema.regex(regex, field.validation.pattern.message);\n    }\n  }\n\n  return fieldSchema;\n};\n\n/**\n * 数値フィールド用の検証\n */\nexport const addNumberValidation = (\n  fieldSchema: z.ZodString,\n  field: {\n    label: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, any>) => string\n) => {\n  return fieldSchema.superRefine((val, ctx) => {\n    if (val === '') return;\n\n    const num = Number(val);\n    if (isNaN(num)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('number'),\n      });\n      return;\n    }\n\n    if (field.validation?.min !== undefined && num < field.validation.min) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('greater', { label: field.label, min: field.validation.min }),\n      });\n    }\n\n    if (field.validation?.max !== undefined && num > field.validation.max) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('lesser', { label: field.label, max: field.validation.max }),\n      });\n    }\n  });\n};\n\n/**\n * ZODスキーマをフィールドタイプに基づいて生成\n */\nexport const generateFieldSchemaByType = (\n  field: CommonFieldDefinition,\n  t: (key: string, params?: Record<string, any>) => string,\n  getValidatorFn?: (language: SupportedLanguage) => (content: string) => { isValid: boolean; error?: string; markers?: any[] }\n) => {\n  let fieldSchema = generateFieldSchema(field, t);\n\n  if (field.type === 'number') {\n    return addNumberValidation(fieldSchema, field, t);\n  } \n  \n  if (field.type === 'code' && field.validation?.codeValidation && getValidatorFn && field.language) {\n    const validator = getValidatorFn(field.language);\n    if (validator) {\n      return fieldSchema.superRefine((val, ctx) => {\n        if (!val) return;\n        \n        const result = validator(val);\n        if (!result.isValid) {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: result.error || 'Invalid code format',\n          });\n        }\n      });\n    }\n  }\n\n  return fieldSchema;\n};\n\n/**\n * ネストしたオブジェクトのスキーマを処理する関数\n */\nexport const processNestedSchema = (obj: any): any => {\n  const processed: { [key: string]: any } = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (value instanceof z.ZodType) {\n      processed[key] = value;\n    } else if (typeof value === 'object') {\n      processed[key] = z.object(processNestedSchema(value));\n    }\n  }\n\n  return processed;\n};\n\n/**\n * ネストしたフィールドのパスを処理する関数\n */\nexport const handleNestedField = (\n  obj: Record<string, any>,\n  paths: string[],\n  schema: z.ZodType,\n  fieldType?: string,\n  fieldConfig?: any\n) => {\n  const [first, ...rest] = paths;\n  if (!first) return;\n\n  if (rest.length === 0) {\n    if (fieldType === 'array') {\n      if (fieldConfig?.itemType === 'object' && fieldConfig?.fields) {\n        const objectSchema: Record<string, z.ZodType> = {};\n        fieldConfig.fields.forEach((subField: any) => {\n          objectSchema[subField.name] = z.string();\n        });\n        obj[first] = z.array(z.object(objectSchema));\n      } else {\n        obj[first] = z.array(z.string());\n      }\n    } else {\n      obj[first] = schema;\n    }\n  } else {\n    obj[first] = obj[first] || {};\n    handleNestedField(obj[first] as Record<string, any>, rest, schema, fieldType, fieldConfig);\n  }\n};\n\n/**\n * ネストした値を設定するヘルパー関数\n */\nexport const setNestedValue = (obj: Record<string, any>, path: string[], value: any) => {\n  if (path.length === 0) return obj;\n\n  let current = obj;\n  const lastIndex = path.length - 1;\n\n  for (let i = 0; i < lastIndex; i++) {\n    const key = path[i];\n    if (key) {\n      current[key] = current[key] || {};\n      current = current[key];\n    }\n  }\n\n  const lastKey = path[lastIndex];\n  if (lastKey) {\n    current[lastKey] = value;\n  }\n\n  return obj;\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/schema-generator.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\nimport { \n  CommonFieldDefinition, \n  generateFieldSchemaByType, \n  handleNestedField,\n  processNestedSchema\n} from './resource-form-utils';\nimport { SupportedLanguage } from '@/registry/new-york/blocks/code-editor/code-editor';\n\n/**\n * フィールド定義からZodスキーマを生成する関数\n */\nexport const generateSchema = (\n  fields: CommonFieldDefinition[],\n  t: (key: string, params?: Record<string, any>) => string,\n  codeValidator?: (language: SupportedLanguage) => (content: string) => { isValid: boolean; error?: string; markers?: any[] }\n) => {\n  const schemaObject: Record<string, any> = {};\n\n  // バリデータの取得関数（指定されていればそれを使用）\n  const getValidatorFn = codeValidator;\n\n  fields.forEach(field => {\n    if (field.type === 'unit-input') {\n      // ユニット入力には2つのフィールドが必要\n      const valueSchema = generateFieldSchemaByType(field, t, getValidatorFn);\n      const unitSchema = z.string().min(1, t('unit'));\n\n      schemaObject[`${field.name}Value`] = valueSchema;\n      schemaObject[`${field.name}Unit`] = unitSchema;\n    } else {\n      // 通常のフィールド\n      const fieldSchema = generateFieldSchemaByType(field, t, getValidatorFn);\n\n      const fieldPath = field.name.split('.');\n      if (fieldPath.length > 1) {\n        // ネストされたフィールド\n        handleNestedField(schemaObject, fieldPath, fieldSchema, field.type, field);\n      } else {\n        // トップレベルフィールド\n        if (field.type === 'array') {\n          if (field.itemType === 'object' && field.fields) {\n            const objectSchema: Record<string, z.ZodType> = {};\n            field.fields.forEach(subField => {\n              objectSchema[subField.name] = z.string();\n            });\n            schemaObject[field.name] = z.array(z.object(objectSchema));\n          } else {\n            schemaObject[field.name] = z.array(z.string());\n          }\n        } else {\n          schemaObject[field.name] = fieldSchema;\n        }\n      }\n    }\n  });\n\n  return z.object(processNestedSchema(schemaObject));\n};\n\n/**\n * デフォルト値を生成する関数\n */\nexport const generateDefaultValues = (\n  fields: CommonFieldDefinition[],\n  existingValues: Record<string, any> = {}\n): Record<string, any> => {\n  return fields.reduce((acc: Record<string, any>, field) => {\n    if (field.type === 'unit-input') {\n      const defaultUnit = field.defaultUnit || field.units?.[0]?.value || '';\n      acc[`${field.name}Value`] = field.defaultValue?.toString() || '';\n      acc[`${field.name}Unit`] = defaultUnit;\n    } else if (field.type === 'array') {\n      acc[field.name] = existingValues[field.name] || [];\n    } else {\n      acc[field.name] = field.defaultValue?.toString() || existingValues[field.name] || '';\n    }\n    return acc;\n  }, {});\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/en.json",
      "content": "{\n  \"components\": {\n    \"resource-form\": {\n      \"created-success\": \"Resource created successfully\",\n      \"updated-success\": \"Resource updated successfully\",\n      \"created-error\": \"Error creating resource\",\n      \"updated-error\": \"Error updating resource\",\n      \"fetch-error\": \"Failed to fetch resource\",\n      \"cancel\": \"Cancel\",\n      \"creating\": \"Creating...\",\n      \"updating\": \"Updating...\",\n      \"create\": \"Create\",\n      \"update\": \"Update\",\n      \"prev\": \"Previous\",\n      \"next\": \"Next\",\n      \"step\": \"Step\",\n      \"need\": \"{label} is required\",\n      \"textlesser\": \"{label} must be less than {maxLength} characters\",\n      \"number\": \"Must be a number\",\n      \"greater\": \"{label} must be greater than or equal to {min}\",\n      \"lesser\": \"{label} must be less than or equal to {max}\",\n      \"select\": \"Select {label}\",\n      \"add\": \"Add\",\n      \"unit\": \"Please select a unit\",\n      \"error\": \"An error occurred\",\n      \"loading\": \"Loading resource data...\",\n      \"syntax-error-message\": \"There are syntax errors. Please fix them before submitting.\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/en.json"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/ja.json",
      "content": "{\n  \"components\": {\n    \"resource-form\": {\n      \"created-success\": \"リソースが作成されました\",\n      \"updated-success\": \"リソースが更新されました\",\n      \"created-error\": \"リソースの作成中にエラーが発生しました\",\n      \"updated-error\": \"リソースの更新中にエラーが発生しました\",\n      \"fetch-error\": \"リソースの取得に失敗しました\",\n      \"cancel\": \"キャンセル\",\n      \"creating\": \"作成中...\",\n      \"updating\": \"更新中...\",\n      \"create\": \"作成\",\n      \"update\": \"更新\",\n      \"prev\": \"前へ\",\n      \"next\": \"次へ\",\n      \"step\": \"ステップ\",\n      \"need\": \"{label}は必須項目です\",\n      \"textlesser\": \"{label}は{maxLength}文字以内で入力してください\",\n      \"number\": \"数値を入力してください\",\n      \"greater\": \"{label}は{min}以上の値を入力してください\",\n      \"lesser\": \"{label}は{max}以下の値を入力してください\",\n      \"select\": \"{label}を選択\",\n      \"add\": \"追加\",\n      \"unit\": \"単位を選択してください\",\n      \"error\": \"エラーが発生しました\",\n      \"loading\": \"リソースデータを読み込み中...\",\n      \"syntax-error-message\": \"構文エラーがあります。エラーを修正してから送信してください。\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/ja.json"
    }
  ]
}