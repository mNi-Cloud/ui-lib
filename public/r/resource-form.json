{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "resource-form",
  "type": "registry:component",
  "title": "Resource Form",
  "description": "A resource create/edit form component.",
  "dependencies": [
    "next-intl",
    "@hookform/resolvers",
    "react-hook-form",
    "sonner",
    "zod"
  ],
  "registryDependencies": [
    "form",
    "card",
    "input",
    "select",
    "button",
    "alert",
    "progress"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/resource-form/resource-form.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { toast } from 'sonner';\nimport { useTranslations } from 'next-intl';\nimport { Card, CardContent } from '@/registry/new-york/ui/card';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { Form } from '@/registry/new-york/ui/form';\nimport { Progress } from '@/registry/new-york/ui/progress';\nimport { Alert, AlertDescription } from '@/registry/new-york/ui/alert';\nimport { AlertCircle } from 'lucide-react';\nimport { CommonFieldDefinition, StepDefinition } from './resource-form-utils';\nimport { generateSchema, generateDefaultValues } from './schema-generator';\nimport FieldRenderer from './field-renderer';\nimport YamlEditor from './yaml-editor';\nimport { validateYaml } from './yaml-utils';\n\n// 単一ステップフォーム用の型定義\nexport type ResourceFormProps = {\n  title: string;\n  resourceType: string;\n  fields: CommonFieldDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: any) => any;\n  defaultValues?: Record<string, any>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\n// 複数ステップフォーム用の型定義\nexport type MultiStepResourceFormProps = {\n  title: string;\n  resourceType: string;\n  steps: StepDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  formatFormData?: (data: any) => any;\n  defaultValues?: Record<string, any>;\n  resourceId?: string;\n  isEditMode?: boolean;\n};\n\n/**\n * リソース作成・編集フォーム\n */\nexport const ResourceForm: React.FC<ResourceFormProps> = ({\n  title,\n  resourceType,\n  fields,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  formatFormData,\n  defaultValues = {},\n  resourceId,\n  isEditMode = false\n}) => {\n  const router = useRouter();\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [isLoading, setIsLoading] = useState(isEditMode && !!resourceId);\n  const t = useTranslations(isEditMode ? 'components.resource-edit' : 'components.resource-create');\n\n  const messages = {\n    success: successMessage || t('successmessage'),\n    error: errorMessage || t('errormessage')\n  };\n\n  const safeFields = Array.isArray(fields) ? fields : [];\n  \n  // ZODスキーマ生成\n  const formSchema = generateSchema(safeFields, t);\n  type FormValues = z.infer<typeof formSchema>;\n\n  // フォーム初期化\n  const form = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: generateDefaultValues(safeFields, defaultValues)\n  });\n\n  // 編集モードの場合、リソースデータを取得\n  useEffect(() => {\n    const fetchResource = async () => {\n      if (isEditMode && resourceId) {\n        setIsLoading(true);\n        try {\n          const response = await fetch(`${apiEndpoint}/${resourceId}`);\n          if (!response.ok) {\n            throw new Error(t('fetcherror'));\n          }\n          const data = await response.json();\n          \n          // ネストしたフィールドの値を設定\n          safeFields.forEach(field => {\n            const parts = field.name.split('.');\n            if (parts.length > 1) {\n              let value = data;\n              for (const part of parts) {\n                value = value?.[part];\n                if (value === undefined) break;\n              }\n              if (value !== undefined) {\n                form.setValue(field.name, value);\n              }\n            } else {\n              if (data[field.name] !== undefined) {\n                form.setValue(field.name, data[field.name]);\n              }\n            }\n          });\n        } catch (err) {\n          console.error('Failed to fetch resource:', err);\n          setError(t('fetcherror'));\n        } finally {\n          setIsLoading(false);\n        }\n      }\n    };\n\n    fetchResource();\n  }, [apiEndpoint, resourceId, isEditMode, form, safeFields, t]);\n\n  // フォーム送信処理\n  const onSubmit = async (values: FormValues) => {\n    setLoading(true);\n    try {\n      const formattedData = formatFormData ? formatFormData(values) : values;\n      \n      const url = isEditMode && resourceId ? `${apiEndpoint}/${resourceId}` : apiEndpoint;\n      const method = isEditMode ? 'PUT' : 'POST';\n\n      const response = await fetch(url, {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          'Accept': 'application/json',\n        },\n        body: JSON.stringify(formattedData),\n      });\n\n      if (!response.ok) {\n        throw new Error(messages.error);\n      }\n\n      // リソース名を取得（最初のフィールドかnameフィールドから）\n      let resourceName = '';\n      if (formattedData && typeof formattedData === 'object') {\n        if ('name' in formattedData && typeof formattedData.name === 'string') {\n          resourceName = formattedData.name;\n        } else if (safeFields[0] && values[safeFields[0].name]) {\n          resourceName = String(values[safeFields[0].name]);\n        }\n      }\n\n      toast.success(messages.success, {\n        description: isEditMode \n          ? t('updated', { resourceName: resourceName || resourceType })\n          : t('created', { resourceName: resourceName || resourceType }),\n        duration: 5000,\n      });\n      \n      router.push(redirectPath);\n    } catch (error) {\n      toast.error(t('error'), {\n        description: messages.error,\n        duration: 5000,\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const onCancel = () => {\n    router.push(redirectPath);\n    toast.info(isEditMode ? t('canceledit') : t('cancelcreate'), {\n      duration: 3000,\n    });\n  };\n\n  if (isLoading) {\n    return (\n      <Card>\n        <CardContent className=\"p-6\">\n          <div className=\"space-y-4\">\n            <h1 className=\"text-2xl font-semibold mb-2\">{title}</h1>\n            <div className=\"space-y-2\">\n              <div className=\"text-sm text-muted-foreground\">{t('loading')}</div>\n              <Progress value={undefined} className=\"h-2\" />\n            </div>\n          </div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (error) {\n    return (\n      <Card>\n        <CardContent className=\"p-6\">\n          <div className=\"space-y-4\">\n            <h1 className=\"text-2xl font-semibold mb-2\">{title}</h1>\n            <Alert variant=\"destructive\">\n              <AlertCircle className=\"h-4 w-4\" />\n              <AlertDescription>{error}</AlertDescription>\n            </Alert>\n            <Button onClick={() => router.push(redirectPath)}>{t('back')}</Button>\n          </div>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  return (\n    <Card>\n      <CardContent className=\"p-6\">\n        <div className=\"space-y-6\">\n          <div>\n            <h1 className=\"text-2xl font-semibold mb-2\">{title}</h1>\n          </div>\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n              {safeFields.map(field => (\n                <FieldRenderer \n                  key={`field-${field.name}`}\n                  field={field} \n                  form={form}\n                  translationNamespace={isEditMode ? 'components.resource-edit' : 'components.resource-create'}\n                  yamlEditor={YamlEditor}\n                  validateYaml={validateYaml}\n                />\n              ))}\n              <div className=\"flex justify-end gap-2\">\n                <Button\n                  type=\"button\"\n                  variant=\"outline\"\n                  onClick={onCancel}\n                >\n                  {t('cancel')}\n                </Button>\n                <Button\n                  type=\"submit\"\n                  disabled={loading}\n                >\n                  {loading ? (\n                    <div className=\"flex items-center\">\n                      <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n                      {isEditMode ? t('updating') : t('creating')}\n                    </div>\n                  ) : (\n                    isEditMode ? t('update') : t('create')\n                  )}\n                </Button>\n              </div>\n            </form>\n          </Form>\n        </div>\n      </CardContent>\n    </Card>\n  );\n};\n\n/**\n * 複数ステップリソース作成フォーム\n */\nexport const MultiStepResourceForm: React.FC<MultiStepResourceFormProps> = ({\n  title,\n  resourceType,\n  steps,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  formatFormData\n}) => {\n  const router = useRouter();\n  const [currentStep, setCurrentStep] = useState(0);\n  const [loading, setLoading] = useState(false);\n  const [formData, setFormData] = useState<{ [key: string]: any }>({});\n  const t = useTranslations('components.resource-create-multiple');\n\n  const messages = {\n    success: successMessage || t('successmessage'),\n    error: errorMessage || t('errormessage')\n  };\n\n  // ステップの存在確認\n  if (steps.length === 0) {\n    return (\n      <div className=\"p-4\">\n        <p className=\"text-destructive\">{t('nostep')}</p>\n        <Button\n          className=\"mt-4\"\n          variant=\"outline\"\n          onClick={() => router.push(redirectPath)}\n        >\n          {t('back')}\n        </Button>\n      </div>\n    );\n  }\n\n  // 現在のステップを確認\n  const currentStepIndex = currentStep < 0 || currentStep >= steps.length ? 0 : currentStep;\n  const currentStepData = steps[currentStepIndex];\n\n  // ZODスキーマ生成\n  const currentStepSchema = generateSchema(currentStepData.fields, t);\n  type FormValues = z.infer<typeof currentStepSchema>;\n\n  // フォーム初期化\n  const form = useForm<FormValues>({\n    resolver: zodResolver(currentStepSchema),\n    defaultValues: generateDefaultValues(currentStepData.fields, formData)\n  });\n\n  // ステップ送信処理\n  const handleStepSubmit = async (values: FormValues) => {\n    const updatedFormData = {\n      ...formData,\n      ...values\n    };\n\n    setFormData(updatedFormData);\n\n    if (currentStepIndex === steps.length - 1) {\n      // 最終ステップの場合、APIに送信\n      setLoading(true);\n      try {\n        const dataToSubmit = formatFormData ? formatFormData(updatedFormData) : updatedFormData;\n\n        const response = await fetch(apiEndpoint, {\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json',\n          },\n          body: JSON.stringify(dataToSubmit),\n        });\n        \n        if (!response.ok) {\n          throw new Error(messages.error);\n        }\n\n        // リソース名を取得\n        const firstField = steps[0]?.fields[0];\n        const resourceName = firstField\n          ? updatedFormData[firstField.name] || t('resource')\n          : t('resource');\n\n        toast.success(messages.success, {\n          description: t('created', { resourceName }),\n          duration: 5000,\n        });\n\n        router.push(redirectPath);\n      } catch (error) {\n        toast.error(t('error'), {\n          description: messages.error,\n          duration: 5000,\n        });\n      } finally {\n        setLoading(false);\n      }\n    } else {\n      // 次のステップに進む\n      setCurrentStep(currentStep + 1);\n    }\n  };\n\n  const onPreviousStep = () => {\n    if (currentStep > 0) {\n      setCurrentStep(currentStep - 1);\n    }\n  };\n\n  const onCancel = () => {\n    router.push(redirectPath);\n    toast.info(t('cancelcreate'), {\n      duration: 3000,\n    });\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"mb-4\">\n        <h1 className=\"text-2xl font-semibold\">{title}</h1>\n        {steps.length > 1 && (\n          <div className=\"mt-4\">\n            <div className=\"flex justify-between mb-1\">\n              <span className=\"text-sm\">{t('step')} {currentStepIndex + 1} / {steps.length}</span>\n              <span className=\"text-sm\">{currentStepData.title}</span>\n            </div>\n            <Progress value={((currentStepIndex + 1) / steps.length) * 100} className=\"h-2\" />\n          </div>\n        )}\n      </div>\n\n      <Card>\n        <CardContent className=\"p-6\">\n          {currentStepData.description && (\n            <p className=\"text-muted-foreground mb-6\">{currentStepData.description}</p>\n          )}\n\n          <Form {...form}>\n            <form className=\"space-y-6\">\n              {currentStepData.fields.map(field => (\n                <FieldRenderer\n                  key={`field-${field.name}`}\n                  field={field}\n                  form={form}\n                  translationNamespace=\"components.resource-create-multiple\"\n                  yamlEditor={YamlEditor}\n                  validateYaml={validateYaml}\n                />\n              ))}\n            </form>\n          </Form>\n        </CardContent>\n      </Card>\n\n      <div className=\"flex justify-between\">\n        <div>\n          {currentStepIndex > 0 && (\n            <Button\n              variant=\"outline\"\n              onClick={onPreviousStep}\n              type=\"button\"\n            >\n              {t('prevstep')}\n            </Button>\n          )}\n        </div>\n        <div className=\"flex space-x-2\">\n          <Button\n            variant=\"outline\"\n            onClick={onCancel}\n            type=\"button\"\n          >\n            {t('cancel')}\n          </Button>\n          <Button\n            onClick={form.handleSubmit(handleStepSubmit)}\n            disabled={loading}\n          >\n            {loading ? (\n              <div className=\"flex items-center\">\n                <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n                {t('creating')}\n              </div>\n            ) : currentStepIndex === steps.length - 1 ? (\n              t('create')\n            ) : (\n              t('nextstep')\n            )}\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default { ResourceForm, MultiStepResourceForm }; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/field-renderer.tsx",
      "content": "'use client';\n\nimport React from 'react';\nimport { useFieldArray } from 'react-hook-form';\nimport { Input } from '@/registry/new-york/ui/input';\nimport { Textarea } from '@/registry/new-york/ui/textarea';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/registry/new-york/ui/select';\nimport {\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n  FormDescription,\n} from '@/registry/new-york/ui/form';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { X } from 'lucide-react';\nimport { useTranslations } from 'next-intl';\nimport { \n  CommonFieldDefinition, \n  CommonFieldObjectDefinition \n} from './resource-form-utils';\n\ninterface ArrayItemRecord {\n  [key: string]: string;\n}\n\ntype FieldRendererProps = {\n  field: CommonFieldDefinition;\n  form: any;\n  fieldNamePrefix?: string;\n  translationNamespace?: string;\n  yamlEditor?: React.ComponentType<{\n    value: string;\n    onChange: (value: string) => void;\n    readOnly?: boolean;\n    height?: string;\n    placeholder?: string;\n    disabled?: boolean;\n    showValidation?: boolean;\n  }>;\n  validateYaml?: (content: string) => { isValid: boolean; error?: string };\n};\n\nexport const FieldRenderer: React.FC<FieldRendererProps> = ({\n  field,\n  form,\n  fieldNamePrefix = '',\n  translationNamespace = 'components.resource-create',\n  yamlEditor: YamlEditor,\n  validateYaml\n}) => {\n  const t = useTranslations(translationNamespace);\n  const fieldName = fieldNamePrefix ? `${fieldNamePrefix}.${field.name}` : field.name;\n\n  // readOnlyメッセージの表示\n  const renderReadOnlyMessage = () => {\n    if (field.readOnly && field.readOnlyMessage) {\n      return (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      );\n    }\n    return null;\n  };\n\n  // カスタムコンポーネントの処理\n  if (field.type === 'custom' && field.render) {\n    return (\n      <div key={`form-field-${fieldName}`}>\n        {field.render({ \n          values: form.getValues(), \n          form \n        })}\n      </div>\n    );\n  }\n\n  // ユニット入力の処理\n  if (field.type === 'unit-input') {\n    return (\n      <div key={`form-field-${fieldName}`} className=\"space-y-2\">\n        <div className=\"space-y-1\">\n          <FormLabel className=\"text-sm font-medium\">\n            {field.label}\n            {field.validation?.required && (\n              <span className=\"text-destructive ml-1\">*</span>\n            )}\n          </FormLabel>\n          {field.description && (\n            <FormDescription className=\"text-xs\">\n              {field.description}\n            </FormDescription>\n          )}\n          {renderReadOnlyMessage()}\n        </div>\n\n        <div className=\"flex flex-col md:flex-row gap-2 w-full\">\n          <div className=\"flex-grow\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Value`}\n              render={({ field: formField }) => (\n                <FormControl>\n                  <Input\n                    type=\"number\"\n                    placeholder={field.placeholder}\n                    className={field.readOnly ? 'bg-muted' : 'h-10'}\n                    value={formField.value}\n                    onChange={(e) => {\n                      formField.onChange(e);\n                      const unit = form.getValues(`${fieldName}Unit`);\n                      form.setValue(fieldName, `${e.target.value}${unit}`);\n                    }}\n                    readOnly={field.readOnly}\n                  />\n                </FormControl>\n              )}\n            />\n          </div>\n\n          <div className=\"w-full md:w-[160px]\">\n            <FormField\n              control={form.control}\n              name={`${fieldName}Unit`}\n              render={({ field: formField }) => (\n                <Select\n                  value={formField.value}\n                  defaultValue={field.defaultUnit}\n                  onValueChange={(value) => {\n                    formField.onChange(value);\n                    const numValue = form.getValues(`${fieldName}Value`);\n                    form.setValue(fieldName, `${numValue}${value}`);\n                  }}\n                  disabled={field.disabled || field.readOnly}\n                >\n                  <FormControl>\n                    <SelectTrigger className={field.readOnly ? 'bg-muted h-10' : 'h-10'}>\n                      <SelectValue />\n                    </SelectTrigger>\n                  </FormControl>\n                  <SelectContent>\n                    {field.units?.map((unit) => (\n                      <SelectItem\n                        key={`${fieldName}-unit-${unit.value}`}\n                        value={unit.value}\n                      >\n                        {unit.label}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              )}\n            />\n          </div>\n        </div>\n        <FormMessage className=\"text-xs\" />\n      </div>\n    );\n  }\n\n  // YAML入力の処理\n  if (field.type === 'yaml' && YamlEditor) {\n    return (\n      <FormField\n        key={`form-field-${fieldName}`}\n        control={form.control}\n        name={fieldName}\n        render={({ field: formField }) => (\n          <FormItem className=\"space-y-2\">\n            <div className=\"space-y-1\">\n              <FormLabel className=\"text-sm font-medium\">\n                {field.label}\n                {field.validation?.required && (\n                  <span className=\"text-destructive ml-1\">*</span>\n                )}\n              </FormLabel>\n              {field.description && (\n                <FormDescription className=\"text-xs\">\n                  {field.description}\n                </FormDescription>\n              )}\n              {renderReadOnlyMessage()}\n            </div>\n            <FormControl>\n              <YamlEditor\n                value={formField.value}\n                onChange={(value) => {\n                  if (!field.readOnly) {\n                    formField.onChange(value);\n                    if (field.validation?.yamlLint && validateYaml) {\n                      const { isValid, error } = validateYaml(value);\n                      if (!isValid) {\n                        form.setError(fieldName, {\n                          type: 'manual',\n                          message: error,\n                        });\n                      } else {\n                        form.clearErrors(fieldName);\n                      }\n                    }\n                  }\n                }}\n                readOnly={field.readOnly}\n              />\n            </FormControl>\n            <FormMessage className=\"text-xs\" />\n          </FormItem>\n        )}\n      />\n    );\n  }\n\n  // 配列フィールドの処理\n  if (field.type === 'array') {\n    return <ArrayFieldRenderer field={field} form={form} fieldName={fieldName} t={t} />;\n  }\n\n  // 一般的なフィールドの処理（テキスト、数値、メール、パスワード、セレクト、テキストエリア）\n  return (\n    <FormField\n      key={`form-field-${fieldName}`}\n      control={form.control}\n      name={fieldName}\n      render={({ field: formField }) => (\n        <FormItem className=\"space-y-2\">\n          <div className=\"space-y-1\">\n            <FormLabel className=\"text-sm font-medium\">\n              {field.label}\n              {field.validation?.required && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n            </FormLabel>\n            {field.description && (\n              <FormDescription className=\"text-xs\">\n                {field.description}\n              </FormDescription>\n            )}\n            {renderReadOnlyMessage()}\n          </div>\n          <FormControl>\n            {field.type === 'select' ? (\n              <Select\n                value={formField.value || ''}\n                onValueChange={(value) => {\n                  if (!field.readOnly) {\n                    formField.onChange(value);\n                    field.onChange?.(value);\n                  }\n                }}\n                disabled={field.disabled || field.readOnly}\n              >\n                <SelectTrigger className={field.readOnly ? 'bg-muted h-10' : 'h-10'}>\n                  <SelectValue placeholder={field.placeholder} />\n                </SelectTrigger>\n                <SelectContent>\n                  {field.options?.map((option) => (\n                    <SelectItem\n                      key={`${fieldName}-option-${option.value}`}\n                      value={option.value}\n                    >\n                      {option.label}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            ) : field.type === 'textarea' ? (\n              <Textarea\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                readOnly={field.readOnly}\n                className={field.readOnly ? 'bg-muted' : ''}\n                {...formField}\n                onChange={(e) => {\n                  if (!field.readOnly) {\n                    formField.onChange(e);\n                    field.onChange?.(e.target.value);\n                  }\n                }}\n              />\n            ) : (\n              <Input\n                type={field.type}\n                placeholder={field.placeholder}\n                disabled={field.disabled}\n                readOnly={field.readOnly}\n                className={field.readOnly ? 'bg-muted' : ''}\n                {...formField}\n                onChange={(e) => {\n                  if (!field.readOnly) {\n                    formField.onChange(e);\n                    field.onChange?.(e.target.value);\n                  }\n                }}\n              />\n            )}\n          </FormControl>\n          <FormMessage className=\"text-xs\" />\n        </FormItem>\n      )}\n    />\n  );\n};\n\n// 配列フィールドのレンダリングを処理する内部コンポーネント\nconst ArrayFieldRenderer: React.FC<{\n  field: CommonFieldDefinition;\n  form: any;\n  fieldName: string;\n  t: (key: string, params?: any) => string;\n}> = ({ field, form, fieldName, t }) => {\n  const { fields, append, remove } = useFieldArray({\n    control: form.control,\n    name: fieldName,\n  });\n\n  const addNewItem = () => {\n    if (field.readOnly) return;\n\n    if (field.itemType === 'object' && field.fields) {\n      const newItem = field.fields.reduce<Record<string, any>>((acc, fieldItem) => {\n        acc[fieldItem.name] = fieldItem.type === 'number' ? null : '';\n        return acc;\n      }, {});\n      append(newItem);\n    } else {\n      append('');\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <FormLabel>\n          {field.label}\n          {field.validation?.required && (\n            <span className=\"text-destructive ml-1\">*</span>\n          )}\n        </FormLabel>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={addNewItem}\n          disabled={field.readOnly}\n        >\n          {t('add')}\n        </Button>\n      </div>\n      {field.description && (\n        <FormDescription className=\"text-xs\">\n          {field.description}\n        </FormDescription>\n      )}\n      {field.readOnly && field.readOnlyMessage && (\n        <FormDescription className=\"text-amber-500 dark:text-amber-400 mt-1\">\n          {field.readOnlyMessage}\n        </FormDescription>\n      )}\n\n      {fields.map((arrayField, index) => (\n        <div key={arrayField.id} className=\"relative\">\n          {field.itemType === 'object' ? (\n            <div className=\"flex gap-4 items-start\">\n              {field.fields?.map((subField) => (\n                <FormField\n                  key={`${arrayField.id}-${subField.name}`}\n                  control={form.control}\n                  name={`${fieldName}.${index}.${subField.name}`}\n                  render={({ field: formField }) => (\n                    <FormItem className=\"flex-1\">\n                      <FormLabel>{subField.label}</FormLabel>\n                      <FormControl>\n                        {subField.type === 'select' ? (\n                          <Select\n                            value={formField.value?.toString() || ''}\n                            onValueChange={(value) => {\n                              if (!field.readOnly) {\n                                formField.onChange(value);\n                                if (subField.onChange) {\n                                  subField.onChange(value);\n                                }\n                              }\n                            }}\n                            disabled={subField.disabled || field.readOnly}\n                          >\n                            <SelectTrigger className={field.readOnly ? 'bg-muted' : ''}>\n                              <SelectValue\n                                placeholder={subField.placeholder || t('select', { label: subField.label })}\n                              />\n                            </SelectTrigger>\n                            <SelectContent>\n                              {subField.options?.map((option) => (\n                                <SelectItem\n                                  key={`${subField.name}-${index}-option-${option.value}`}\n                                  value={option.value}\n                                >\n                                  {option.label}\n                                </SelectItem>\n                              ))}\n                            </SelectContent>\n                          </Select>\n                        ) : (\n                          <Input\n                            type={subField.type}\n                            placeholder={subField.placeholder}\n                            className={field.readOnly ? 'bg-muted' : ''}\n                            disabled={subField.disabled || field.readOnly}\n                            readOnly={field.readOnly}\n                            value={formField.value ?? ''}\n                            onChange={(e) => {\n                              if (!field.readOnly) {\n                                const value = subField.type === 'number'\n                                  ? e.target.value === '' ? null : Number(e.target.value)\n                                  : e.target.value;\n                                formField.onChange(value);\n                                if (subField.onChange) {\n                                  subField.onChange(value);\n                                }\n                              }\n                            }}\n                          />\n                        )}\n                      </FormControl>\n                      <FormMessage />\n                      {subField.description && (\n                        <FormDescription>{subField.description}</FormDescription>\n                      )}\n                    </FormItem>\n                  )}\n                />\n              ))}\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  className=\"mt-8\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          ) : (\n            <div className=\"flex gap-2\">\n              <FormField\n                control={form.control}\n                name={`${fieldName}.${index}`}\n                render={({ field: formField }) => (\n                  <FormItem className=\"flex-1\">\n                    <FormControl>\n                      <Input\n                        className={field.readOnly ? 'bg-muted' : ''}\n                        readOnly={field.readOnly}\n                        disabled={field.readOnly}\n                        {...formField}\n                        onChange={(e) => {\n                          if (!field.readOnly) {\n                            formField.onChange(e);\n                          }\n                        }}\n                      />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              {!field.readOnly && (\n                <Button\n                  type=\"button\"\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  onClick={() => remove(index)}\n                >\n                  <X className=\"h-4 w-4\" />\n                </Button>\n              )}\n            </div>\n          )}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default FieldRenderer; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/yaml-editor.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { Textarea } from '@/registry/new-york/ui/textarea';\nimport { validateYaml, yamlExamples } from './yaml-utils';\n\ntype YamlEditorProps = {\n  value: string;\n  onChange: (value: string) => void;\n  height?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  showValidation?: boolean;\n  readOnly?: boolean;\n};\n\nexport const YamlEditor: React.FC<YamlEditorProps> = ({\n  value,\n  onChange,\n  height = '300px',\n  placeholder = 'YAMLを入力してください',\n  disabled = false,\n  showValidation = false,\n  readOnly = false\n}) => {\n  const [error, setError] = useState<string | null>(null);\n\n  const handleChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    if (readOnly) return;\n    \n    const newValue = e.target.value;\n    onChange(newValue);\n\n    if (showValidation) {\n      const result = validateYaml(newValue);\n      if (!result.isValid) {\n        setError(result.error || 'Invalid YAML format');\n      } else {\n        setError(null);\n      }\n    }\n  };\n\n  useEffect(() => {\n    if (showValidation && value) {\n      const result = validateYaml(value);\n      if (!result.isValid) {\n        setError(result.error || 'Invalid YAML format');\n      } else {\n        setError(null);\n      }\n    }\n  }, [value, showValidation]);\n\n  return (\n    <div className=\"space-y-2\">\n      <Textarea\n        value={value}\n        onChange={handleChange}\n        placeholder={placeholder}\n        disabled={disabled}\n        readOnly={readOnly}\n        className={`font-mono text-sm leading-relaxed ${error ? 'border-destructive' : ''} ${readOnly ? 'bg-muted' : ''}`}\n        style={{ minHeight: height, height: 'auto' }}\n      />\n      {showValidation && error && (\n        <div className=\"text-xs text-destructive\">{error}</div>\n      )}\n    </div>\n  );\n};\n\nexport default YamlEditor; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/resource-form-utils.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\n\n/**\n * 共通の型定義\n */\nexport type SelectOption = {\n  value: string;\n  label: string;\n};\n\nexport type UnitOption = SelectOption;\n\nexport type ValidationPattern = {\n  value: string;\n  flags?: string;\n  message: string;\n};\n\nexport type BaseFieldValidation = {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: ValidationPattern;\n  yamlLint?: boolean;\n};\n\nexport type BaseFieldDefinition = {\n  name: string;\n  label: string;\n  placeholder?: string;\n  description?: string;\n  validation?: BaseFieldValidation;\n  disabled?: boolean;\n  onChange?: (value: any) => void;\n  defaultValue?: string | number;\n  readOnly?: boolean;\n  readOnlyMessage?: string;\n};\n\n/**\n * すべてのフィールドタイプの共通定義\n */\nexport type CommonFieldType = \n  'text' | 'number' | 'email' | 'password' | 'select' | \n  'array' | 'unit-input' | 'textarea' | 'yaml' | 'custom';\n\nexport type CommonFieldObjectDefinition = Omit<BaseFieldDefinition, 'onChange'> & {\n  type: 'text' | 'number' | 'email' | 'password' | 'select';\n  options?: SelectOption[];\n  onChange?: (value: any) => void;\n};\n\nexport type CommonFieldDefinition = BaseFieldDefinition & {\n  type: CommonFieldType;\n  // 各タイプに必要な追加プロパティ\n  options?: SelectOption[];         // select用\n  units?: UnitOption[];             // unit-input用\n  defaultUnit?: string;             // unit-input用\n  itemType?: 'text' | 'object';     // array用\n  fields?: CommonFieldObjectDefinition[]; // array+object用\n  render?: (props: { values: any; form: any }) => React.ReactNode; // custom用\n};\n\n/**\n * 複数ステップフォーム用の定義\n */\nexport type StepDefinition = {\n  title: string;\n  description?: string;\n  fields: CommonFieldDefinition[];\n};\n\n/**\n * 共通のスキーマ生成関数\n */\nexport const generateFieldSchema = (\n  field: {\n    name: string;\n    label: string;\n    type?: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, any>) => string\n) => {\n  let fieldSchema = z.string();\n\n  if (field.validation) {\n    if (field.validation.required) {\n      fieldSchema = fieldSchema.min(1, t('need', { label: field.label }));\n    }\n\n    if (field.validation.maxLength) {\n      fieldSchema = fieldSchema.max(\n        field.validation.maxLength,\n        t('textlesser', { label: field.label, maxLength: field.validation.maxLength })\n      );\n    }\n\n    if (field.validation.pattern) {\n      const regex = new RegExp(\n        field.validation.pattern.value,\n        field.validation.pattern.flags\n      );\n      fieldSchema = fieldSchema.regex(regex, field.validation.pattern.message);\n    }\n  }\n\n  return fieldSchema;\n};\n\n/**\n * 数値フィールド用の検証\n */\nexport const addNumberValidation = (\n  fieldSchema: z.ZodString,\n  field: {\n    label: string;\n    validation?: BaseFieldValidation;\n  },\n  t: (key: string, params?: Record<string, any>) => string\n) => {\n  return fieldSchema.superRefine((val, ctx) => {\n    if (val === '') return;\n\n    const num = Number(val);\n    if (isNaN(num)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('number'),\n      });\n      return;\n    }\n\n    if (field.validation?.min !== undefined && num < field.validation.min) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('greater', { label: field.label, min: field.validation.min }),\n      });\n    }\n\n    if (field.validation?.max !== undefined && num > field.validation.max) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: t('lesser', { label: field.label, max: field.validation.max }),\n      });\n    }\n  });\n};\n\n/**\n * ZODスキーマをフィールドタイプに基づいて生成\n */\nexport const generateFieldSchemaByType = (\n  field: CommonFieldDefinition,\n  t: (key: string, params?: Record<string, any>) => string,\n  validateYaml?: (content: string) => { isValid: boolean; error?: string }\n) => {\n  let fieldSchema = generateFieldSchema(field, t);\n\n  if (field.type === 'number') {\n    return addNumberValidation(fieldSchema, field, t);\n  } \n  \n  if (field.type === 'yaml' && field.validation?.yamlLint && validateYaml) {\n    return fieldSchema.superRefine((val, ctx) => {\n      if (!val) return;\n      \n      const result = validateYaml(val);\n      if (!result.isValid) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: result.error || 'Invalid YAML format',\n        });\n      }\n    });\n  }\n\n  return fieldSchema;\n};\n\n/**\n * ネストしたオブジェクトのスキーマを処理する関数\n */\nexport const processNestedSchema = (obj: any): any => {\n  const processed: { [key: string]: any } = {};\n\n  for (const [key, value] of Object.entries(obj)) {\n    if (value instanceof z.ZodType) {\n      processed[key] = value;\n    } else if (typeof value === 'object') {\n      processed[key] = z.object(processNestedSchema(value));\n    }\n  }\n\n  return processed;\n};\n\n/**\n * ネストしたフィールドのパスを処理する関数\n */\nexport const handleNestedField = (\n  obj: Record<string, any>,\n  paths: string[],\n  schema: z.ZodType,\n  fieldType?: string,\n  fieldConfig?: any\n) => {\n  const [first, ...rest] = paths;\n  if (!first) return;\n\n  if (rest.length === 0) {\n    if (fieldType === 'array') {\n      if (fieldConfig?.itemType === 'object' && fieldConfig?.fields) {\n        const objectSchema: Record<string, z.ZodType> = {};\n        fieldConfig.fields.forEach((subField: any) => {\n          objectSchema[subField.name] = z.string();\n        });\n        obj[first] = z.array(z.object(objectSchema));\n      } else {\n        obj[first] = z.array(z.string());\n      }\n    } else {\n      obj[first] = schema;\n    }\n  } else {\n    obj[first] = obj[first] || {};\n    handleNestedField(obj[first] as Record<string, any>, rest, schema, fieldType, fieldConfig);\n  }\n};\n\n/**\n * ネストした値を設定するヘルパー関数\n */\nexport const setNestedValue = (obj: Record<string, any>, path: string[], value: any) => {\n  if (path.length === 0) return obj;\n\n  let current = obj;\n  const lastIndex = path.length - 1;\n\n  for (let i = 0; i < lastIndex; i++) {\n    const key = path[i];\n    if (key) {\n      current[key] = current[key] || {};\n      current = current[key];\n    }\n  }\n\n  const lastKey = path[lastIndex];\n  if (lastKey) {\n    current[lastKey] = value;\n  }\n\n  return obj;\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/schema-generator.ts",
      "content": "'use client';\n\nimport { z } from 'zod';\nimport { \n  CommonFieldDefinition, \n  generateFieldSchemaByType, \n  handleNestedField,\n  processNestedSchema\n} from './resource-form-utils';\nimport { validateYaml } from './yaml-utils';\n\n/**\n * フィールド定義からZodスキーマを生成する関数\n */\nexport const generateSchema = (\n  fields: CommonFieldDefinition[],\n  t: (key: string, params?: Record<string, any>) => string\n) => {\n  const schemaObject: Record<string, any> = {};\n\n  fields.forEach(field => {\n    if (field.type === 'unit-input') {\n      // ユニット入力には2つのフィールドが必要\n      const valueSchema = generateFieldSchemaByType(field, t, validateYaml);\n      const unitSchema = z.string().min(1, t('unit'));\n\n      schemaObject[`${field.name}Value`] = valueSchema;\n      schemaObject[`${field.name}Unit`] = unitSchema;\n    } else {\n      // 通常のフィールド\n      const fieldSchema = generateFieldSchemaByType(field, t, validateYaml);\n\n      const fieldPath = field.name.split('.');\n      if (fieldPath.length > 1) {\n        // ネストされたフィールド\n        handleNestedField(schemaObject, fieldPath, fieldSchema, field.type, field);\n      } else {\n        // トップレベルフィールド\n        if (field.type === 'array') {\n          if (field.itemType === 'object' && field.fields) {\n            const objectSchema: Record<string, z.ZodType> = {};\n            field.fields.forEach(subField => {\n              objectSchema[subField.name] = z.string();\n            });\n            schemaObject[field.name] = z.array(z.object(objectSchema));\n          } else {\n            schemaObject[field.name] = z.array(z.string());\n          }\n        } else {\n          schemaObject[field.name] = fieldSchema;\n        }\n      }\n    }\n  });\n\n  return z.object(processNestedSchema(schemaObject));\n};\n\n/**\n * デフォルト値を生成する関数\n */\nexport const generateDefaultValues = (\n  fields: CommonFieldDefinition[],\n  existingValues: Record<string, any> = {}\n): Record<string, any> => {\n  return fields.reduce((acc: Record<string, any>, field) => {\n    if (field.type === 'unit-input') {\n      const defaultUnit = field.defaultUnit || field.units?.[0]?.value || '';\n      acc[`${field.name}Value`] = field.defaultValue?.toString() || '';\n      acc[`${field.name}Unit`] = defaultUnit;\n    } else if (field.type === 'array') {\n      acc[field.name] = existingValues[field.name] || [];\n    } else {\n      acc[field.name] = field.defaultValue?.toString() || existingValues[field.name] || '';\n    }\n    return acc;\n  }, {});\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/yaml-utils.ts",
      "content": "'use client';\n\n// YAMLクライアントサイド検証用\nimport * as YAML from 'yaml';\n\n/**\n * YAML文字列を検証する関数\n * @param content 検証するYAML文字列\n * @returns 検証結果と、エラーがあればエラーメッセージを含むオブジェクト\n */\nexport function validateYaml(content: string): { isValid: boolean; error?: string } {\n  if (!content.trim()) {\n    return { isValid: true };\n  }\n\n  try {\n    YAML.parse(content);\n    return { isValid: true };\n  } catch (error) {\n    return { \n      isValid: false, \n      error: error instanceof Error ? error.message : 'Invalid YAML format' \n    };\n  }\n}\n\n/**\n * YAMLの書式の例\n */\nexport const yamlExamples = {\n  basic: `# 基本的なYAML例\nname: John Doe\nage: 30\nisActive: true\n`,\n  array: `# 配列の例\nfruits:\n  - apple\n  - banana\n  - orange\n`,\n  nested: `# ネストされたオブジェクトの例\nperson:\n  name: Jane Smith\n  address:\n    street: 123 Main St\n    city: Anytown\n    zip: 12345\n  hobbies:\n    - reading\n    - swimming\n`\n}; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/en.json",
      "content": "{\n  \"components\": {\n    \"resource-create\": {\n      \"need\": \"{label} is required\",\n      \"textlesser\": \"{label} must be {maxLength} characters or less\",\n      \"number\": \"Please enter a number\",\n      \"greater\": \"{label} must be greater than or equal to {min}\",\n      \"lesser\": \"{label} must be less than or equal to {max}\",\n      \"successmessage\": \"Resource created successfully\",\n      \"errormessage\": \"An error occurred while creating the resource\",\n      \"created\": \"{resourceName} has been created\",\n      \"error\": \"An error occurred\",\n      \"cancelcreate\": \"Creation cancelled\",\n      \"cancel\": \"Cancel\",\n      \"creating\": \"Creating...\",\n      \"create\": \"Create\",\n      \"select\": \"Select {label}\",\n      \"add\": \"Add\"\n    },\n    \"resource-edit\": {\n      \"need\": \"{label} is required\",\n      \"textlesser\": \"{label} must be {maxLength} characters or less\",\n      \"number\": \"Please enter a number\",\n      \"greater\": \"{label} must be greater than or equal to {min}\",\n      \"lesser\": \"{label} must be less than or equal to {max}\",\n      \"successmessage\": \"Resource update completed successfully\",\n      \"errormessage\": \"An error occurred while updating the resource\",\n      \"created\": \"{resourceName} has been created\",\n      \"updated\": \"Updated '{resourceName}'\",\n      \"error\": \"Error\",\n      \"cancelcreate\": \"Creation cancelled\",\n      \"canceledit\": \"Edit cancelled\",\n      \"cancel\": \"Cancel\",\n      \"creating\": \"Creating...\",\n      \"updating\": \"Updating...\",\n      \"create\": \"Create\",\n      \"update\": \"Update\",\n      \"select\": \"Select {label}\",\n      \"add\": \"Add\",\n      \"loading\": \"Loading resource data...\",\n      \"fetcherror\": \"Failed to fetch resource\",\n      \"back\": \"Back\"\n    },\n    \"resource-create-multiple\": {\n      \"need\": \"{label} is required\",\n      \"textlesser\": \"{label} must be {maxLength} characters or less\",\n      \"number\": \"Please enter a number\",\n      \"greater\": \"{label} must be greater than or equal to {min}\",\n      \"lesser\": \"{label} must be less than or equal to {max}\",\n      \"unit\": \"Please select a unit\",\n      \"successmessage\": \"Resource created successfully\",\n      \"errormessage\": \"An error occurred while creating the resource\",\n      \"created\": \"{resourceName} has been created\",\n      \"resource\": \"Resource\",\n      \"error\": \"An error occurred\",\n      \"nostep\": \"No steps defined\",\n      \"back\": \"Back\",\n      \"cancelcreate\": \"Creation cancelled\",\n      \"step\": \"Step\",\n      \"prevstep\": \"Previous Step\",\n      \"cancel\": \"Cancel\",\n      \"creating\": \"Creating...\",\n      \"create\": \"Create\",\n      \"nextstep\": \"Next Step\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/en.json"
    },
    {
      "path": "registry/new-york/blocks/resource-form/messages/ja.json",
      "content": "{\n  \"components\": {\n    \"resource-create\": {\n      \"need\": \"{label}は必須項目です\",\n      \"textlesser\": \"{label}は{maxLength}文字以内で入力してください\",\n      \"number\": \"数値を入力してください\",\n      \"greater\": \"{label}は{min}以上の値を入力してください\",\n      \"lesser\": \"{label}は{max}以下の値を入力してください\",\n      \"successmessage\": \"リソースが作成されました\",\n      \"errormessage\": \"リソースの作成中にエラーが発生しました\",\n      \"created\": \"{resourceName}が作成されました\",\n      \"error\": \"エラーが発生しました\",\n      \"cancelcreate\": \"作成がキャンセルされました\",\n      \"cancel\": \"キャンセル\",\n      \"creating\": \"作成中...\",\n      \"create\": \"作成\",\n      \"select\": \"{label}を選択\",\n      \"add\": \"追加\"\n    },\n    \"resource-edit\": {\n      \"need\": \"{label}は必須項目です\",\n      \"textlesser\": \"{label}は{maxLength}文字以内で入力してください\",\n      \"number\": \"数値を入力してください\",\n      \"greater\": \"{label}は{min}以上の値を入力してください\",\n      \"lesser\": \"{label}は{max}以下の値を入力してください\",\n      \"successmessage\": \"リソースの更新が完了しました\",\n      \"errormessage\": \"リソースの更新中にエラーが発生しました\",\n      \"created\": \"{resourceName}が作成されました\",\n      \"updated\": \"「{resourceName}」を更新しました\",\n      \"error\": \"エラー\",\n      \"cancelcreate\": \"作成がキャンセルされました\",\n      \"canceledit\": \"編集をキャンセルしました\",\n      \"cancel\": \"キャンセル\",\n      \"creating\": \"作成中...\",\n      \"updating\": \"更新中...\",\n      \"create\": \"作成\",\n      \"update\": \"更新\",\n      \"select\": \"{label}を選択\",\n      \"add\": \"追加\",\n      \"loading\": \"リソースデータを読み込み中...\",\n      \"fetcherror\": \"リソースの取得に失敗しました\",\n      \"back\": \"戻る\"\n    },\n    \"resource-create-multiple\": {\n      \"need\": \"{label}は必須項目です\",\n      \"textlesser\": \"{label}は{maxLength}文字以内で入力してください\",\n      \"number\": \"数値を入力してください\",\n      \"greater\": \"{label}は{min}以上の値を入力してください\",\n      \"lesser\": \"{label}は{max}以下の値を入力してください\",\n      \"unit\": \"単位を選択してください\",\n      \"successmessage\": \"リソースが作成されました\",\n      \"errormessage\": \"リソースの作成中にエラーが発生しました\",\n      \"created\": \"{resourceName}が作成されました\",\n      \"resource\": \"リソース\",\n      \"error\": \"エラーが発生しました\",\n      \"nostep\": \"ステップが定義されていません\",\n      \"back\": \"戻る\",\n      \"cancelcreate\": \"作成がキャンセルされました\",\n      \"step\": \"ステップ\",\n      \"prevstep\": \"前のステップ\",\n      \"cancel\": \"キャンセル\",\n      \"creating\": \"作成中...\",\n      \"create\": \"作成\",\n      \"nextstep\": \"次のステップ\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-form/ja.json"
    }
  ]
}