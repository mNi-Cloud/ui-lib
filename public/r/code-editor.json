{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "code-editor",
  "type": "registry:component",
  "title": "Code Editor",
  "description": "A code editor component with language support and validation based on Monaco Editor.",
  "dependencies": [
    "@monaco-editor/react",
    "next-themes"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/code-editor/code-editor.tsx",
      "content": "'use client';\n\nimport React, { useRef, useEffect, useState } from 'react';\nimport dynamic from 'next/dynamic';\nimport { Loader2 } from 'lucide-react';\nimport { useTheme } from 'next-themes';\nimport { \n  SupportedLanguage,\n  MonacoMarker, \n  getValidator, \n  applyMarkersToModel,\n  getLanguagePlugin,\n  getLanguageLabel,\n  initializeLanguagePlugins\n} from '@/registry/new-york/blocks/code-editor/language-plugins/language-plugins';\n\n// 初期化時に言語プラグインをロード\nif (typeof window !== 'undefined') {\n  // クライアントサイドでのみ実行\n  initializeLanguagePlugins();\n}\n\n// Monaco Editorをクライアントサイドでのみロードするために動的にインポート\nconst MonacoEditor = dynamic(() => import('@monaco-editor/react'), {\n  ssr: false,\n  loading: () => (\n    <div className=\"flex items-center justify-center min-h-[300px] border rounded-md bg-muted/30\">\n      <Loader2 className=\"h-6 w-6 animate-spin text-muted-foreground\" />\n    </div>\n  ),\n});\n\n// サポートする言語とそのバリデーション関数の型\ntype LanguageValidatorFn = (content: string) => { isValid: boolean; error?: string; markers?: MonacoMarker[] };\n\n// プロパティの型定義\ntype CodeEditorProps = {\n  value: string;\n  onChange: (value: string) => void;\n  language?: SupportedLanguage;\n  height?: string;\n  placeholder?: string;\n  disabled?: boolean;\n  readOnly?: boolean;\n  showValidation?: boolean;\n  validator?: LanguageValidatorFn;\n  theme?: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light';\n  useMarkers?: boolean;\n};\n\nexport const CodeEditor: React.FC<CodeEditorProps> = ({\n  value,\n  onChange,\n  language = 'plaintext',\n  height = '300px',\n  placeholder = 'コードを入力してください',\n  disabled = false,\n  readOnly = false,\n  showValidation = true,\n  validator: customValidator,\n  theme: propTheme,\n  useMarkers = true,\n}) => {\n  const monacoRef = useRef<any>(null);\n  const editorRef = useRef<any>(null);\n  const modelRef = useRef<any>(null);\n  const [error, setError] = useState<string | null>(null);\n  const { resolvedTheme } = useTheme();\n  \n  // テーマの決定: プロパティで指定された場合はそれを使用、それ以外はアプリケーションのテーマに従う\n  const theme = propTheme || (resolvedTheme === 'dark' ? 'vs-dark' : 'vs');\n  \n  // システムテーマが変更された時にエディタのテーマも更新\n  useEffect(() => {\n    if (!propTheme && editorRef.current && monacoRef.current) {\n      const newTheme = resolvedTheme === 'dark' ? 'vs-dark' : 'vs';\n      monacoRef.current.editor.setTheme(newTheme);\n    }\n  }, [resolvedTheme, propTheme]);\n  \n  // バリデーターの取得 (カスタムバリデーターが渡されていればそれを使用、なければプラグインシステムから取得)\n  const validator = customValidator || getValidator(language);\n  \n  // バリデーション処理を共通化\n  const validateContent = (content: string) => {\n    if (!showValidation || !validator) return;\n    \n    const result = validator(content);\n    \n    if (!result.isValid) {\n      setError(result.error || '不正なフォーマットです');\n      \n      // Markersの適用（useMarkersがtrueかつmarkersが存在する場合）\n      if (useMarkers && result.markers && monacoRef.current && modelRef.current) {\n        applyMarkersToModel(monacoRef.current, modelRef.current, result.markers);\n      }\n    } else {\n      setError(null);\n      \n      // エラーがなくなったらマーカーをクリア\n      if (useMarkers && monacoRef.current && modelRef.current) {\n        applyMarkersToModel(monacoRef.current, modelRef.current, []);\n      }\n    }\n  };\n  \n  // エディタが初期化されたときの処理\n  const handleEditorDidMount = (editor: any, monaco: any) => {\n    editorRef.current = editor;\n    monacoRef.current = monaco;\n    modelRef.current = editor.getModel();\n\n    // 初期テーマを明示的に設定\n    const currentTheme = resolvedTheme === 'dark' ? 'vs-dark' : 'vs';\n    monaco.editor.setTheme(currentTheme);\n\n    // プレースホルダーテキストの設定\n    if (!value && placeholder) {\n      editor.getModel()?.setValue(placeholder);\n      editor.onDidFocusEditorText(() => {\n        if (editor.getValue() === placeholder) {\n          editor.getModel()?.setValue('');\n        }\n      });\n      editor.onDidBlurEditorText(() => {\n        if (editor.getValue() === '') {\n          editor.getModel()?.setValue(placeholder);\n        }\n      });\n    }\n\n    // 言語プラグインのMonaco設定を適用\n    const languagePlugin = getLanguagePlugin(language);\n    if (languagePlugin?.setupMonaco) {\n      languagePlugin.setupMonaco(monaco);\n    }\n\n    // 初期バリデーション\n    if (value) {\n      validateContent(value);\n    }\n  };\n\n  // エディタの内容が変更されたときの処理\n  const handleEditorChange = (newValue: string | undefined) => {\n    if (readOnly || disabled) return;\n    \n    const content = newValue || '';\n    onChange(content);\n\n    // バリデーション\n    validateContent(content);\n  };\n\n  // 値が変更されたときのバリデーション\n  useEffect(() => {\n    if (value) {\n      validateContent(value);\n    }\n  }, [value]);\n\n  // クリーンアップ関数\n  useEffect(() => {\n    return () => {\n      // コンポーネントがアンマウントされるときにマーカーをクリア\n      if (useMarkers && monacoRef.current && modelRef.current) {\n        applyMarkersToModel(monacoRef.current, modelRef.current, []);\n      }\n    };\n  }, [useMarkers]);\n\n  // 言語ラベルの取得\n  const languageLabel = getLanguageLabel(language);\n\n  return (\n    <div className=\"space-y-2\">\n      <div \n        className={`border rounded-md overflow-hidden relative ${error ? 'border-destructive' : 'border-input'} ${readOnly ? 'bg-muted/30' : ''}`}\n      >\n        {/* 言語ラベルバッジ */}\n        <div className=\"absolute top-1 right-1 z-10 px-2 py-0.5 rounded bg-primary/10 text-xs font-medium text-primary-foreground backdrop-blur-sm\">\n          {languageLabel}\n        </div>\n\n        <MonacoEditor\n          value={value}\n          onChange={handleEditorChange}\n          language={language}\n          height={height}\n          theme={theme}\n          options={{\n            minimap: { enabled: true },\n            scrollBeyondLastLine: false,\n            lineNumbers: 'on',\n            folding: true,\n            wordWrap: 'on',\n            automaticLayout: true,\n            contextmenu: true,\n            scrollbar: {\n              useShadows: false,\n              verticalScrollbarSize: 10,\n              horizontalScrollbarSize: 10,\n              alwaysConsumeMouseWheel: false\n            },\n            lineNumbersMinChars: 3,\n            readOnly: readOnly || disabled,\n            renderLineHighlight: 'all',\n          }}\n          onMount={handleEditorDidMount}\n        />\n      </div>\n      {showValidation && error && !useMarkers && (\n        <div className=\"text-xs text-destructive\">{error}</div>\n      )}\n    </div>\n  );\n};\n\nexport default CodeEditor; ",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/code-editor/language-plugins/language-plugins.ts",
      "content": "// 型をエクスポート\nexport type { SupportedLanguage } from './language-plugins-types';\n\n// コア機能をエクスポート\nexport {\n  registerLanguagePlugin,\n  getLanguagePlugin,\n  getValidator,\n  applyMarkersToModel,\n  initializeLanguagePlugins\n} from './language-plugins-core';\n\n// コアの型をエクスポート\nexport type { MonacoMarker, LanguagePlugin } from './language-plugins-core';\n\n// ユーティリティ関数をエクスポート\nexport {\n  getLanguageLabel, \n  getLanguageExtension,\n  createSimplePlugin,\n  codeExamples\n} from './language-plugins-utils';\n\n// 言語プラグインモジュールをインポート（自動登録）\nimport './yaml-plugin';\nimport './json-plugin';\nimport './typescript-plugin'; ",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/code-editor/language-plugins/language-plugins-types.ts",
      "content": "// サポートされる言語タイプの定義\nexport type SupportedLanguage = 'yaml' | 'json' | 'javascript' | 'typescript' | 'html' | 'css' | 'markdown' | 'plaintext';\n\n// プラグインインターフェース\nexport interface LanguagePlugin {\n  language: SupportedLanguage;\n  validate: (content: string) => { isValid: boolean; error?: string; markers?: MonacoMarker[] };\n  getModelOptions?: () => any;\n  setupMonaco?: (monaco: any) => void;\n}\n\n// Monaco Editorのマーカー型定義\nexport interface MonacoMarker {\n  startLineNumber: number;\n  startColumn: number;\n  endLineNumber: number;\n  endColumn: number;\n  message: string;\n  severity: number; // monaco.MarkerSeverity の値\n}\n\n// 言語名の取得\nexport const getLanguageLabel = (language: SupportedLanguage): string => {\n  const labels: Record<SupportedLanguage, string> = {\n    yaml: 'YAML',\n    json: 'JSON',\n    javascript: 'JavaScript',\n    typescript: 'TypeScript',\n    html: 'HTML',\n    css: 'CSS',\n    markdown: 'Markdown',\n    plaintext: 'プレーンテキスト'\n  };\n  \n  return labels[language] || language;\n};\n\n// 言語のファイル拡張子\nexport const getLanguageExtension = (language: SupportedLanguage): string => {\n  const extensions: Record<SupportedLanguage, string> = {\n    yaml: 'yml',\n    json: 'json',\n    javascript: 'js',\n    typescript: 'ts',\n    html: 'html',\n    css: 'css',\n    markdown: 'md',\n    plaintext: 'txt'\n  };\n  \n  return extensions[language];\n}; ",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/code-editor/language-plugins/language-plugins-core.ts",
      "content": "import { SupportedLanguage } from './language-plugins-types';\n\n// プラグインインターフェース\nexport interface LanguagePlugin {\n  language: SupportedLanguage;\n  validate: (content: string) => { isValid: boolean; error?: string; markers?: MonacoMarker[] };\n  getModelOptions?: () => any;\n  setupMonaco?: (monaco: any) => void;\n}\n\n// Monaco Editorのマーカー型定義\nexport interface MonacoMarker {\n  startLineNumber: number;\n  startColumn: number;\n  endLineNumber: number;\n  endColumn: number;\n  message: string;\n  severity: number; // monaco.MarkerSeverity の値\n}\n\n// プラグインレジストリ\nconst languagePlugins: Map<SupportedLanguage, LanguagePlugin> = new Map();\n\n// プラグインの登録\nexport function registerLanguagePlugin(plugin: LanguagePlugin) {\n  languagePlugins.set(plugin.language, plugin);\n}\n\n// プラグインの取得\nexport function getLanguagePlugin(language: SupportedLanguage): LanguagePlugin | undefined {\n  return languagePlugins.get(language);\n}\n\n// バリデーターの取得\nexport function getValidator(language: SupportedLanguage) {\n  return languagePlugins.get(language)?.validate || (() => ({ isValid: true, error: undefined, markers: [] }));\n}\n\n// Monaco EditorのMarkers APIを使用してエラーを表示する関数\nexport function applyMarkersToModel(monaco: any, model: any, markers: MonacoMarker[], owner: string = 'linter') {\n  if (model && monaco) {\n    monaco.editor.setModelMarkers(model, owner, markers);\n  }\n}\n\n// 言語プラグインの初期化\nexport function initializeLanguagePlugins() {\n  // プラグインが既に登録されている場合は何もしない\n  if (languagePlugins.size > 0) return;\n  \n  // ここでプラグインを登録\n  // コアモジュールでは各言語プラグインをインポートせず、\n  // language-plugins.tsで個別にimportしてregisterLanguagePluginを呼び出すことで\n  // 循環参照を防止します\n}\n\n// 各言語のサンプル\nexport const codeExamples: Record<SupportedLanguage, string> = {\n  yaml: `# 基本的なYAMLの例\nname: example-service\nversion: 1.0.0\ndescription: A simple example service\nspec:\n  replicas: 3\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8080\n  selector:\n    app: example\n`,\n  json: `{\n  \"name\": \"example-service\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A simple example service\",\n  \"spec\": {\n    \"replicas\": 3,\n    \"ports\": [\n      {\n        \"name\": \"http\",\n        \"port\": 80,\n        \"targetPort\": 8080\n      }\n    ],\n    \"selector\": {\n      \"app\": \"example\"\n    }\n  }\n}`,\n  javascript: `// 基本的なJavaScriptの例\nfunction calculateTotal(items) {\n  return items\n    .map(item => item.price * item.quantity)\n    .reduce((total, value) => total + value, 0);\n}\n\nconst items = [\n  { name: 'Item 1', price: 100, quantity: 2 },\n  { name: 'Item 2', price: 200, quantity: 1 }\n];\n\nconsole.log(calculateTotal(items));`,\n  typescript: `// 基本的なTypeScriptの例\ninterface Item {\n  name: string;\n  price: number;\n  quantity: number;\n}\n\nfunction calculateTotal(items: Item[]): number {\n  return items\n    .map(item => item.price * item.quantity)\n    .reduce((total, value) => total + value, 0);\n}\n\nconst items: Item[] = [\n  { name: 'Item 1', price: 100, quantity: 2 },\n  { name: 'Item 2', price: 200, quantity: 1 }\n];\n\nconsole.log(calculateTotal(items));`,\n  html: `<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Example Page</title>\n</head>\n<body>\n  <h1>Example Page</h1>\n  <p>This is an example HTML page.</p>\n</body>\n</html>`,\n  css: `/* 基本的なCSSの例 */\nbody {\n  font-family: 'Helvetica Neue', Arial, sans-serif;\n  line-height: 1.6;\n  color: #333;\n  margin: 0;\n  padding: 20px;\n}\n\nh1 {\n  color: #0066cc;\n  border-bottom: 1px solid #eee;\n  padding-bottom: 10px;\n}\n\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n}`,\n  markdown: `# マークダウンの例\n\n## 見出し\n\nこれは**太字**で、これは*イタリック*です。\n\n- リストアイテム1\n- リストアイテム2\n- リストアイテム3\n\n[リンク](https://example.com)\n\n\\`\\`\\`js\n// コードブロック\nfunction hello() {\n  console.log('Hello, world!');\n}\n\\`\\`\\``,\n  plaintext: `これはプレーンテキストの例です。\n特別な書式は適用されません。\n複数行のテキストを入力できます。`\n};\n\n// その他の言語のプラグイン（簡易版）\nexport const createSimplePlugin = (language: SupportedLanguage): LanguagePlugin => ({\n  language,\n  validate: () => ({ isValid: true, markers: [] }),\n  setupMonaco: () => {}\n});\n\n// 言語名の取得\nexport const getLanguageLabel = (language: SupportedLanguage): string => {\n  const labels: Record<SupportedLanguage, string> = {\n    yaml: 'YAML',\n    json: 'JSON',\n    javascript: 'JavaScript',\n    typescript: 'TypeScript',\n    html: 'HTML',\n    css: 'CSS',\n    markdown: 'Markdown',\n    plaintext: 'プレーンテキスト'\n  };\n  \n  return labels[language] || language;\n};\n\n// 言語のファイル拡張子\nexport const getLanguageExtension = (language: SupportedLanguage): string => {\n  const extensions: Record<SupportedLanguage, string> = {\n    yaml: 'yml',\n    json: 'json',\n    javascript: 'js',\n    typescript: 'ts',\n    html: 'html',\n    css: 'css',\n    markdown: 'md',\n    plaintext: 'txt'\n  };\n  \n  return extensions[language];\n}; ",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/code-editor/language-plugins/language-plugins-utils.ts",
      "content": "import { SupportedLanguage } from './language-plugins-types';\nimport type { LanguagePlugin } from './language-plugins-core';\n\n// 各言語のサンプル\nexport const codeExamples: Record<SupportedLanguage, string> = {\n  yaml: `# 基本的なYAMLの例\nname: example-service\nversion: 1.0.0\ndescription: A simple example service\nspec:\n  replicas: 3\n  ports:\n    - name: http\n      port: 80\n      targetPort: 8080\n  selector:\n    app: example\n`,\n  json: `{\n  \"name\": \"example-service\",\n  \"version\": \"1.0.0\",\n  \"description\": \"A simple example service\",\n  \"spec\": {\n    \"replicas\": 3,\n    \"ports\": [\n      {\n        \"name\": \"http\",\n        \"port\": 80,\n        \"targetPort\": 8080\n      }\n    ],\n    \"selector\": {\n      \"app\": \"example\"\n    }\n  }\n}`,\n  javascript: `// 基本的なJavaScriptの例\nfunction calculateTotal(items) {\n  return items\n    .map(item => item.price * item.quantity)\n    .reduce((total, value) => total + value, 0);\n}\n\nconst items = [\n  { name: 'Item 1', price: 100, quantity: 2 },\n  { name: 'Item 2', price: 200, quantity: 1 }\n];\n\nconsole.log(calculateTotal(items));`,\n  typescript: `// 基本的なTypeScriptの例\ninterface Item {\n  name: string;\n  price: number;\n  quantity: number;\n}\n\nfunction calculateTotal(items: Item[]): number {\n  return items\n    .map(item => item.price * item.quantity)\n    .reduce((total, value) => total + value, 0);\n}\n\nconst items: Item[] = [\n  { name: 'Item 1', price: 100, quantity: 2 },\n  { name: 'Item 2', price: 200, quantity: 1 }\n];\n\nconsole.log(calculateTotal(items));`,\n  html: `<!DOCTYPE html>\n<html lang=\"ja\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Example Page</title>\n</head>\n<body>\n  <h1>Example Page</h1>\n  <p>This is an example HTML page.</p>\n</body>\n</html>`,\n  css: `/* 基本的なCSSの例 */\nbody {\n  font-family: 'Helvetica Neue', Arial, sans-serif;\n  line-height: 1.6;\n  color: #333;\n  margin: 0;\n  padding: 20px;\n}\n\nh1 {\n  color: #0066cc;\n  border-bottom: 1px solid #eee;\n  padding-bottom: 10px;\n}\n\n.container {\n  max-width: 1200px;\n  margin: 0 auto;\n}`,\n  markdown: `# マークダウンの例\n\n## 見出し\n\nこれは**太字**で、これは*イタリック*です。\n\n- リストアイテム1\n- リストアイテム2\n- リストアイテム3\n\n[リンク](https://example.com)\n\n\\`\\`\\`js\n// コードブロック\nfunction hello() {\n  console.log('Hello, world!');\n}\n\\`\\`\\``,\n  plaintext: `これはプレーンテキストの例です。\n特別な書式は適用されません。\n複数行のテキストを入力できます。`\n};\n\n// その他の言語のプラグイン（簡易版）\nexport const createSimplePlugin = (language: SupportedLanguage): LanguagePlugin => ({\n  language,\n  validate: () => ({ isValid: true, markers: [] }),\n  setupMonaco: () => {}\n});\n\n// 言語名の取得\nexport const getLanguageLabel = (language: SupportedLanguage): string => {\n  const labels: Record<SupportedLanguage, string> = {\n    yaml: 'YAML',\n    json: 'JSON',\n    javascript: 'JavaScript',\n    typescript: 'TypeScript',\n    html: 'HTML',\n    css: 'CSS',\n    markdown: 'Markdown',\n    plaintext: 'プレーンテキスト'\n  };\n  \n  return labels[language] || language;\n};\n\n// 言語のファイル拡張子\nexport const getLanguageExtension = (language: SupportedLanguage): string => {\n  const extensions: Record<SupportedLanguage, string> = {\n    yaml: 'yml',\n    json: 'json',\n    javascript: 'js',\n    typescript: 'ts',\n    html: 'html',\n    css: 'css',\n    markdown: 'md',\n    plaintext: 'txt'\n  };\n  \n  return extensions[language];\n}; ",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/code-editor/language-plugins/yaml-plugin.ts",
      "content": "import { SupportedLanguage } from './language-plugins-types';\nimport type { LanguagePlugin, MonacoMarker } from './language-plugins-core';\n\n// YAMLプラグイン - Monaco Editorの言語機能に依存\nconst yamlPlugin: LanguagePlugin = {\n  language: 'yaml' as SupportedLanguage,\n  validate: (content: string) => {\n    if (!content.trim()) return { isValid: true, markers: [] };\n    \n    // 簡易的なYAML構文チェック（Monacoの言語機能に任せる前の基本検証）\n    const markers: MonacoMarker[] = [];\n    const lines = content.split('\\n');\n    \n    // インデントの整合性チェック（簡易版）\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i].trimEnd();\n      const lineNumber = i + 1;\n      \n      // コメント行はスキップ\n      if (line.trim().startsWith('#')) continue;\n      \n      // 空行はスキップ\n      if (!line.trim()) continue;\n      \n      // コロンの位置チェック\n      if (line.includes(':')) {\n        const colonIndex = line.indexOf(':');\n        const afterColon = line.substring(colonIndex + 1).trim();\n        \n        // キーの後にコロンがあるが値がなく、次の行がインデントされていない場合\n        if (afterColon === '' && i + 1 < lines.length && \n            !lines[i + 1].startsWith(' ') && lines[i + 1].trim() !== '' && \n            !lines[i + 1].trim().startsWith('-') && !lines[i + 1].trim().startsWith('#')) {\n          markers.push({\n            startLineNumber: lineNumber,\n            startColumn: colonIndex + 1,\n            endLineNumber: lineNumber,\n            endColumn: colonIndex + 2,\n            message: 'YAMLの構造エラー: マップのキーの後にはインデントされた値が必要です',\n            severity: 8 // monaco.MarkerSeverity.Error\n          });\n        }\n      }\n      \n      // リストアイテムの不正な構造をチェック\n      if (line.trim().startsWith('-')) {\n        const dashIndex = line.indexOf('-');\n        if (dashIndex > 0) {\n          const indent = dashIndex;\n          const nextLine = i + 1 < lines.length ? lines[i + 1] : '';\n          \n          if (nextLine.trim() && !nextLine.trim().startsWith('-') && \n              !nextLine.startsWith(' '.repeat(indent + 2)) && !nextLine.trim().startsWith('#')) {\n            markers.push({\n              startLineNumber: lineNumber + 1,\n              startColumn: 1,\n              endLineNumber: lineNumber + 1,\n              endColumn: nextLine.length + 1,\n              message: 'YAMLの構造エラー: リストアイテムの下のコンテンツは正しくインデントする必要があります',\n              severity: 8 // monaco.MarkerSeverity.Error\n            });\n          }\n        }\n      }\n    }\n    \n    if (markers.length > 0) {\n      return {\n        isValid: false,\n        error: 'YAML構文エラー',\n        markers\n      };\n    }\n    \n    return { isValid: true, markers: [] };\n  },\n  setupMonaco: (monaco) => {\n    if (!monaco) return;\n    \n    // Monaco EditorのYAML言語サポートの設定\n    monaco.languages.yaml?.defaults?.setDiagnosticsOptions?.({\n      validate: true,\n      schemas: [],\n      enableSchemaRequest: true,\n      format: true\n    });\n    \n    // エディタのテーマに合わせてYAML言語のハイライト設定を調整\n    const currentTheme = monaco.editor.getTheme();\n    if (currentTheme.includes('light')) {\n      // ライトテーマ向けの設定\n      monaco.editor.defineTheme('yaml-light', {\n        base: 'vs',\n        inherit: true,\n        rules: [],\n        colors: {}\n      });\n    }\n  }\n};\n\nimport { registerLanguagePlugin } from './language-plugins-core';\nregisterLanguagePlugin(yamlPlugin);\n\nexport default yamlPlugin; ",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/code-editor/language-plugins/json-plugin.ts",
      "content": "import { SupportedLanguage } from './language-plugins-types';\nimport type { LanguagePlugin, MonacoMarker } from './language-plugins-core';\n\n// JSONプラグイン - 標準的なJSON.parseを使用\nconst jsonPlugin: LanguagePlugin = {\n  language: 'json' as SupportedLanguage,\n  validate: (content: string) => {\n    if (!content.trim()) return { isValid: true, markers: [] };\n    \n    try {\n      // 標準のJSON.parseを使用\n      JSON.parse(content);\n      return { isValid: true, markers: [] };\n    } catch (e) {\n      const error = e as Error;\n      const errorMessage = `JSON構文エラー: ${error.message}`;\n      \n      // エラー位置の抽出を試みる\n      let position = 0;\n      let lineMatch = error.message.match(/at position (\\d+)/i);\n      if (lineMatch) {\n        position = parseInt(lineMatch[1], 10);\n      } else {\n        // JSONエラーメッセージの形式が異なる場合 (at line X column Y)\n        const lineColMatch = error.message.match(/at line (\\d+) column (\\d+)/i);\n        if (lineColMatch) {\n          const errorLine = parseInt(lineColMatch[1], 10);\n          const errorColumn = parseInt(lineColMatch[2], 10);\n          \n          // 行と列から位置を計算\n          const lines = content.split('\\n');\n          for (let i = 0; i < errorLine - 1; i++) {\n            position += lines[i].length + 1; // +1 for newline\n          }\n          position += errorColumn - 1;\n        }\n      }\n      \n      // 行と列の計算\n      const lines = content.split('\\n');\n      let currentPos = 0;\n      let line = 1;\n      let column = 1;\n      \n      for (let i = 0; i < lines.length; i++) {\n        if (currentPos + lines[i].length + 1 > position) {\n          line = i + 1;\n          column = position - currentPos + 1;\n          break;\n        }\n        currentPos += lines[i].length + 1; // +1 for newline\n      }\n      \n      const markers: MonacoMarker[] = [{\n        startLineNumber: line,\n        startColumn: column,\n        endLineNumber: line,\n        endColumn: column + 1,\n        message: errorMessage,\n        severity: 8 // monaco.MarkerSeverity.Error\n      }];\n      \n      return {\n        isValid: false,\n        error: errorMessage,\n        markers\n      };\n    }\n  },\n  setupMonaco: (monaco) => {\n    if (!monaco) return;\n    \n    // Monaco EditorのJSON言語サポートを設定\n    monaco.languages.json?.defaults?.setDiagnosticsOptions?.({\n      validate: true,\n      allowComments: false,\n      schemas: [],\n      enableSchemaRequest: true\n    });\n    \n    // エディタのテーマに合わせてJSON言語のハイライト設定を調整\n    const currentTheme = monaco.editor.getTheme();\n    if (currentTheme.includes('light')) {\n      // ライトテーマ向けの設定\n      monaco.editor.defineTheme('json-light', {\n        base: 'vs',\n        inherit: true,\n        rules: [],\n        colors: {}\n      });\n    }\n  }\n};\n\nimport { registerLanguagePlugin } from './language-plugins-core';\nregisterLanguagePlugin(jsonPlugin);\n\nexport default jsonPlugin; ",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/blocks/code-editor/language-plugins/typescript-plugin.ts",
      "content": "import { SupportedLanguage } from './language-plugins-types';\nimport type { LanguagePlugin, MonacoMarker } from './language-plugins-core';\n\n// TypeScriptの簡易的な構文チェック\nconst validateTypeScript = (content: string): { isValid: boolean; error?: string; markers?: MonacoMarker[] } => {\n  if (!content.trim()) return { isValid: true, markers: [] };\n  \n  const markers: MonacoMarker[] = [];\n  const lines = content.split('\\n');\n  \n  // 簡易的な構文チェック（実際の実装ではTypeScriptコンパイラやESLintが必要）\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    const lineNumber = i + 1;\n    \n    // 未終了のステートメントをチェック\n    if (line.includes('{') && !line.includes('}') && !line.trim().endsWith('{')) {\n      // 単一行に開始括弧はあるが閉じ括弧がない場合（意図的な場合も多いのでマーカーとしては追加しない）\n    }\n    \n    // セミコロンの欠落をチェック（簡易的なチェック）\n    if (line.trim() && \n        !line.trim().endsWith('{') && \n        !line.trim().endsWith('}') && \n        !line.trim().endsWith(';') &&\n        !line.trim().endsWith(',') &&\n        !line.trim().startsWith('//') &&\n        !line.trim().startsWith('import') &&\n        !line.trim().startsWith('export') &&\n        !line.trim().startsWith('function') &&\n        !line.trim().startsWith('interface') &&\n        !line.trim().startsWith('type') &&\n        !line.trim().startsWith('class')) {\n        \n      markers.push({\n        startLineNumber: lineNumber,\n        startColumn: line.length + 1,\n        endLineNumber: lineNumber,\n        endColumn: line.length + 1,\n        message: 'セミコロンが欠落している可能性があります',\n        severity: 4 // monaco.MarkerSeverity.Warning\n      });\n    }\n    \n    // 型の使用法をチェック\n    if (line.includes(':') && !line.includes('?:')) {\n      const parts = line.split(':');\n      if (parts.length > 1) {\n        const typePart = parts[1].trim();\n        \n        // 基本型のスペルミスをチェック\n        const basicTypes = ['string', 'number', 'boolean', 'any', 'void', 'never', 'unknown', 'object'];\n        const typeName = typePart.split(' ')[0].split('|')[0].split('<')[0].trim();\n        \n        if (typeName && \n            !basicTypes.includes(typeName) && \n            !typeName.startsWith('Array') && \n            !typeName.startsWith('[') &&\n            !typeName.startsWith('{') &&\n            !typeName.startsWith('(') &&\n            typeName.length > 0 && \n            typeName[0] === typeName[0].toLowerCase() && \n            basicTypes.some(t => {\n              const distance = levenshteinDistance(t, typeName);\n              return distance > 0 && distance <= 2; // 2文字以内の編集距離\n            })) {\n          \n          const typeIndex = line.indexOf(':') + 1;\n          const typeStart = typeIndex + line.substring(typeIndex).indexOf(typeName);\n          \n          markers.push({\n            startLineNumber: lineNumber,\n            startColumn: typeStart + 1,\n            endLineNumber: lineNumber,\n            endColumn: typeStart + typeName.length + 1,\n            message: '型名のスペルミスの可能性があります',\n            severity: 4 // monaco.MarkerSeverity.Warning\n          });\n        }\n      }\n    }\n  }\n  \n  return {\n    isValid: true, // 警告のみなのでバリデーションは通す\n    markers\n  };\n};\n\n// レーベンシュタイン距離（編集距離）を計算する関数\nfunction levenshteinDistance(a: string, b: string): number {\n  const matrix: number[][] = [];\n  \n  // 行列の初期化\n  for (let i = 0; i <= b.length; i++) {\n    matrix[i] = [i];\n  }\n  \n  for (let j = 0; j <= a.length; j++) {\n    matrix[0][j] = j;\n  }\n  \n  // 距離の計算\n  for (let i = 1; i <= b.length; i++) {\n    for (let j = 1; j <= a.length; j++) {\n      if (b.charAt(i - 1) === a.charAt(j - 1)) {\n        matrix[i][j] = matrix[i - 1][j - 1];\n      } else {\n        matrix[i][j] = Math.min(\n          matrix[i - 1][j - 1] + 1, // 置換\n          matrix[i][j - 1] + 1,     // 挿入\n          matrix[i - 1][j] + 1      // 削除\n        );\n      }\n    }\n  }\n  \n  return matrix[b.length][a.length];\n}\n\n// MonacoエディタへのTypeScript言語の設定\nconst setupTypeScriptMonaco = (monaco: any) => {\n  if (!monaco) return;\n  \n  // TypeScriptの設定\n  monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({\n    noSemanticValidation: false,\n    noSyntaxValidation: false\n  });\n  \n  // コンパイラオプションの設定\n  monaco.languages.typescript.typescriptDefaults.setCompilerOptions({\n    target: monaco.languages.typescript.ScriptTarget.ES2015,\n    allowNonTsExtensions: true,\n    moduleResolution: monaco.languages.typescript.ModuleResolutionKind.NodeJs,\n    module: monaco.languages.typescript.ModuleKind.CommonJS,\n    noEmit: true,\n    typeRoots: [\"node_modules/@types\"]\n  });\n};\n\n// TypeScriptプラグインのエクスポート\nconst typescriptPlugin: LanguagePlugin = {\n  language: 'typescript' as SupportedLanguage,\n  validate: validateTypeScript,\n  setupMonaco: setupTypeScriptMonaco\n};\n\nimport { registerLanguagePlugin } from './language-plugins-core';\nregisterLanguagePlugin(typescriptPlugin);\n\nexport default typescriptPlugin;",
      "type": "registry:lib"
    }
  ]
}