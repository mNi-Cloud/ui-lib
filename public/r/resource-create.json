{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "resource-create",
  "type": "registry:component",
  "title": "Resource Create",
  "description": "A resource creation form component.",
  "dependencies": [
    "next-intl",
    "@hookform/resolvers",
    "react-hook-form",
    "sonner",
    "zod"
  ],
  "registryDependencies": [
    "form",
    "card",
    "input",
    "select",
    "button"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/resource-create/resource-create.tsx",
      "content": "'use client';\n\nimport React, { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { Card, CardContent } from '@/registry/new-york/ui/card';\nimport { Button } from '@/registry/new-york/ui/button';\nimport { Input } from '@/registry/new-york/ui/input';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from '@/registry/new-york/ui/select';\nimport {\n  Form,\n  FormControl,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n  FormDescription,\n} from '@/registry/new-york/ui/form';\nimport { useFieldArray, useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { z } from 'zod';\nimport { toast } from 'sonner';\nimport { X } from 'lucide-react';\nimport { useTranslations } from 'next-intl';\n\ntype ValidationPattern = {\n  value: string;\n  flags?: string;\n  message: string;\n};\n\ntype SelectOption = {\n  value: string;\n  label: string;\n};\n\ntype BaseFieldValidation = {\n  required?: boolean;\n  min?: number;\n  max?: number;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: ValidationPattern;\n};\n\ntype BaseFieldDefinition = {\n  name: string;\n  label: string;\n  placeholder?: string;\n  description?: string;\n  validation?: BaseFieldValidation;\n  disabled?: boolean;\n  onChange?: (value: any) => void;\n};\n\ntype TextFieldDefinition = BaseFieldDefinition & {\n  type: 'text' | 'number' | 'email' | 'password';\n};\n\ntype SelectFieldDefinition = BaseFieldDefinition & {\n  type: 'select';\n  options: SelectOption[];\n};\n\ntype ArrayFieldObjectDefinition = BaseFieldDefinition & {\n  type: 'text' | 'number' | 'email' | 'password' | 'select';\n  options?: SelectOption[];\n};\n\ntype ArrayFieldDefinition = BaseFieldDefinition & {\n  type: 'array';\n  itemType: 'text' | 'object';\n  fields?: ArrayFieldObjectDefinition[];\n};\n\ntype FieldDefinition = TextFieldDefinition | SelectFieldDefinition | ArrayFieldDefinition;\n\ntype ResourceCreateProps = {\n  title: string;\n  resourceType: string;\n  fields: FieldDefinition[];\n  apiEndpoint: string;\n  redirectPath: string;\n  successMessage?: string;\n  errorMessage?: string;\n  onTypeChange?: (newType: string) => void;\n  formatFormData?: (data: any) => any;\n  defaultValues?: Record<string, any>;\n};\n\ninterface ArrayItemRecord {\n  [key: string]: string;\n}\n\nconst ArrayFieldComponent: React.FC<{\n  form: any;\n  field: ArrayFieldDefinition;\n}> = ({ form, field }) => {\n  const t = useTranslations('components.resource-create')\n\n  const { fields = [], append, remove } = useFieldArray({\n    control: form.control,\n    name: field.name,\n  });\n\n  const addNewItem = () => {\n    if (field.itemType === 'object' && field.fields) {\n      const newItem = field.fields.reduce<ArrayItemRecord>((acc, fieldItem) => {\n        acc[fieldItem.name] = '';\n        return acc;\n      }, {});\n      append(newItem);\n    } else {\n      append('');\n    }\n  };\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex justify-between items-center\">\n        <FormLabel>\n          {field.label}\n          {field.validation?.required && (\n            <span className=\"text-destructive ml-1\">*</span>\n          )}\n        </FormLabel>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={addNewItem}\n        >\n          {t('add')}\n        </Button>\n      </div>\n\n      {fields.map((arrayField, index) => (\n        <div key={arrayField.id} className=\"relative\">\n          {field.itemType === 'object' ? (\n            <div className=\"flex gap-4 items-start\">\n              {field.fields?.map((subField) => (\n                <FormField\n                  key={`${arrayField.id}-${subField.name}`}\n                  control={form.control}\n                  name={`${field.name}.${index}.${subField.name}`}\n                  render={({ field: formField }) => (\n                    <FormItem className=\"flex-1\">\n                      <FormLabel>{subField.label}</FormLabel>\n                      <FormControl>\n                        {subField.type === 'select' ? (\n                          <Select\n                            value={formField.value || ''}\n                            onValueChange={(value) => {\n                              formField.onChange(value);\n                              if (subField.onChange) {\n                                subField.onChange(value);\n                              }\n                            }}\n                            disabled={subField.disabled}\n                          >\n                            <SelectTrigger\n                                className=\"w-full\"\n                            >\n                              <SelectValue\n                                placeholder={subField.placeholder || t('select', { label: subField.label })}\n                              />\n                            </SelectTrigger>\n                            <SelectContent>\n                              {subField.options?.map((option) => (\n                                <SelectItem\n                                  key={`${subField.name}-${index}-option-${option.value}`}\n                                  value={option.value}\n                                >\n                                  {option.label}\n                                </SelectItem>\n                              ))}\n                            </SelectContent>\n                          </Select>\n                        ) : (\n                          <Input\n                            type={subField.type}\n                            placeholder={subField.placeholder}\n                            disabled={subField.disabled}\n                            {...formField}\n                          />\n                        )}\n                      </FormControl>\n                      <FormMessage />\n                      {subField.description && (\n                        <FormDescription>{subField.description}</FormDescription>\n                      )}\n                    </FormItem>\n                  )}\n                />\n              ))}\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"icon\"\n                className=\"mt-8\"\n                onClick={() => remove(index)}\n              >\n                <X className=\"h-4 w-4\" />\n              </Button>\n            </div>\n          ) : (\n            <div className=\"flex gap-2\">\n              <FormField\n                control={form.control}\n                name={`${field.name}.${index}`}\n                render={({ field: formField }) => (\n                  <FormItem className=\"flex-1\">\n                    <FormControl>\n                      <Input {...formField} />\n                    </FormControl>\n                    <FormMessage />\n                  </FormItem>\n                )}\n              />\n              <Button\n                type=\"button\"\n                variant=\"ghost\"\n                size=\"icon\"\n                onClick={() => remove(index)}\n              >\n                <X className=\"h-4 w-4\" />\n              </Button>\n            </div>\n          )}\n        </div>\n      ))}\n      {field.description && (\n        <p className=\"text-sm text-muted-foreground\">\n          {field.description}\n        </p>\n      )}\n    </div>\n  );\n};\n\nconst ResourceCreate: React.FC<ResourceCreateProps> = ({\n  title,\n  fields,\n  apiEndpoint,\n  redirectPath,\n  successMessage,\n  errorMessage,\n  onTypeChange,\n  formatFormData,\n  defaultValues = {},\n}) => {\n  const router = useRouter();\n  const [loading, setLoading] = useState(false);\n  const t = useTranslations('components.resource-create')\n\n  const messages = {\n    success: successMessage || t('successmessage'),\n    error: errorMessage || t('errormessage')\n  };\n\n  const safeFields = Array.isArray(fields) ? fields : [];\n\n  const generateZodSchema = (fields: FieldDefinition[]) => {\n    const schemaObject: Record<string, any> = {};\n\n    fields.forEach(field => {\n      let fieldSchema = z.string();\n\n      if (field.validation) {\n        if (field.validation.required) {\n          fieldSchema = fieldSchema.min(1, t('need', { label: field.label }));\n        }\n        if (field.validation.maxLength) {\n          fieldSchema = fieldSchema.max(\n            field.validation.maxLength,\n            t('textlesser', { label: field.label, maxLength: field.validation.maxLength })\n          );\n        }\n        if (field.validation.pattern) {\n          const regex = new RegExp(\n            field.validation.pattern.value,\n            field.validation.pattern.flags\n          );\n          fieldSchema = fieldSchema.regex(regex, field.validation.pattern.message);\n        }\n      }\n\n      const handleNestedField = (\n        obj: Record<string, any>,\n        paths: string[],\n        schema: z.ZodType\n      ) => {\n        const [first, ...rest] = paths;\n        if (!first) return;\n\n        if (rest.length === 0) {\n          if (field.type === 'array') {\n            if (field.itemType === 'object' && field.fields) {\n              const objectSchema: Record<string, z.ZodType> = {};\n              field.fields.forEach(subField => {\n                objectSchema[subField.name] = z.string();\n              });\n              obj[first] = z.array(z.object(objectSchema));\n            } else {\n              obj[first] = z.array(z.string());\n            }\n          } else {\n            obj[first] = schema;\n          }\n        } else {\n          obj[first] = obj[first] || {};\n          handleNestedField(obj[first] as Record<string, any>, rest, schema);\n        }\n      };\n\n      const fieldPath = field.name.split('.');\n      if (fieldPath.length > 1) {\n        handleNestedField(schemaObject, fieldPath, fieldSchema);\n      } else {\n        if (field.type === 'array') {\n          if (field.itemType === 'object' && field.fields) {\n            const objectSchema: Record<string, z.ZodType> = {};\n            field.fields.forEach(subField => {\n              objectSchema[subField.name] = z.string();\n            });\n            schemaObject[field.name] = z.array(z.object(objectSchema));\n          } else {\n            schemaObject[field.name] = z.array(z.string());\n          }\n        } else {\n          schemaObject[field.name] = fieldSchema;\n        }\n      }\n    });\n\n    const processNestedSchema = (obj: any): any => {\n      const processed: { [key: string]: any } = {};\n\n      for (const [key, value] of Object.entries(obj)) {\n        if (value instanceof z.ZodType) {\n          processed[key] = value;\n        } else if (typeof value === 'object') {\n          processed[key] = z.object(processNestedSchema(value));\n        }\n      }\n\n      return processed;\n    };\n\n    return z.object(processNestedSchema(schemaObject));\n  };\n\n  const formSchema = generateZodSchema(safeFields);\n  type FormValues = z.infer<typeof formSchema>;\n\n  const setNestedValue = (obj: Record<string, any>, path: string[], value: any) => {\n    if (path.length === 0) return obj;\n\n    let current = obj;\n    const lastIndex = path.length - 1;\n\n    for (let i = 0; i < lastIndex; i++) {\n      const key = path[i];\n      if (key) {\n        current[key] = current[key] || {};\n        current = current[key];\n      }\n    }\n\n    const lastKey = path[lastIndex];\n    if (lastKey) {\n      current[lastKey] = value;\n    }\n\n    return obj;\n  };\n\n  const form = useForm<FormValues>({\n    resolver: zodResolver(formSchema),\n    defaultValues: {\n      ...safeFields.reduce((acc: Record<string, any>, field) => {\n        const fieldPath = field.name.split('.');\n        const defaultValue = field.type === 'array' ? [] : '';\n        return setNestedValue(acc, fieldPath, defaultValues[field.name] || defaultValue);\n      }, {}),\n      ...defaultValues,\n    },\n  });\n\n  useEffect(() => {\n    const initialValues = safeFields.reduce((acc: Record<string, any>, field) => {\n      const fieldPath = field.name.split('.');\n      const defaultValue = field.type === 'array' ? [] : '';\n      return setNestedValue(acc, fieldPath, defaultValues[field.name] || defaultValue);\n    }, {});\n\n    form.reset({\n      ...initialValues,\n      ...defaultValues,\n    });\n  }, []);\n\n  const createResource = async (data: FormValues) => {\n    const formattedData = formatFormData ? formatFormData(data) : data;\n    const response = await fetch(apiEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n      },\n      body: JSON.stringify(formattedData),\n    });\n\n    if (!response.ok) {\n      throw new Error(messages.error);\n    }\n\n    return response.json();\n  };\n\n  const onSubmit = async (values: FormValues) => {\n    setLoading(true);\n    try {\n      await createResource(values);\n      const formattedData = formatFormData ? formatFormData(values) : values;\n      let resourceName: string = '';\n\n      interface FormattedData {\n        name?: string;\n        [key: string]: any;\n      }\n\n      const formattedName = formattedData &&\n        typeof formattedData === 'object' &&\n        'name' in formattedData &&\n        typeof (formattedData as FormattedData).name === 'string'\n        ? (formattedData as FormattedData).name\n        : null;\n\n      const firstFieldValue = safeFields[0]\n        ? (values as Record<string, any>)[safeFields[0].name]\n        : null;\n\n      if (formattedName) {\n        resourceName = formattedName;\n      } else if (typeof firstFieldValue === 'string') {\n        resourceName = firstFieldValue;\n      }\n\n      toast.success(messages.success, {\n        description: t('created', { resourceName }),\n        duration: 5000,\n      });\n      router.push(redirectPath);\n    } catch (error) {\n      toast.error(t('error'), {\n        description: messages.error,\n        duration: 5000,\n      });\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const onCancel = () => {\n    router.push(redirectPath);\n    toast.info(t('cancelcreate'), {\n      duration: 3000,\n    });\n  };\n\n  const typeValue = form.watch('type');\n  useEffect(() => {\n    if (typeValue && onTypeChange) {\n      onTypeChange(typeValue);\n    }\n  }, [typeValue, onTypeChange]);\n\n  const renderFormField = (field: FieldDefinition) => {\n    if (field.type === 'array') {\n      return (\n        <div key={`array-field-${field.name}`} className=\"space-y-4\">\n          <ArrayFieldComponent form={form} field={field} />\n        </div>\n      );\n    }\n\n    return (\n      <FormField\n        key={`form-field-${field.name}`}\n        control={form.control}\n        name={field.name as any}\n        render={({ field: formField }) => (\n          <FormItem>\n            <FormLabel>\n              {field.label}\n              {field.validation?.required && (\n                <span className=\"text-destructive ml-1\">*</span>\n              )}\n            </FormLabel>\n            <FormControl>\n              {field.type === 'select' ? (\n                <Select\n                  value={formField.value}\n                  onValueChange={(value) => {\n                    formField.onChange(value);\n                    if (field.onChange) {\n                      field.onChange(value);\n                    }\n                  }}\n                  disabled={field.disabled}\n                >\n                  <SelectTrigger>\n                    <SelectValue placeholder={field.placeholder || t('select', { label: field.label })} />\n                  </SelectTrigger>\n                  <SelectContent>\n                    {field.options?.map((option) => (\n                      <SelectItem\n                        key={`${field.name}-option-${option.value}`}\n                        value={option.value}\n                      >\n                        {option.label}\n                      </SelectItem>\n                    ))}\n                  </SelectContent>\n                </Select>\n              ) : (\n                <Input\n                  type={field.type}\n                  placeholder={field.placeholder}\n                  disabled={field.disabled}\n                  {...formField}\n                  onChange={(e) => {\n                    formField.onChange(e);\n                    if (field.onChange) {\n                      field.onChange(e.target.value);\n                    }\n                  }}\n                />\n              )}\n            </FormControl>\n            {field.description && (\n              <FormDescription>{field.description}</FormDescription>\n            )}\n            <FormMessage />\n          </FormItem>\n        )}\n      />\n    );\n  };\n\n  return (\n    <div className=\"pt-4 space-y-4\">\n      <h1 className=\"text-2xl font-semibold\">{title}</h1>\n      <Card>\n        <CardContent className=\"pt-6\">\n          <Form {...form}>\n            <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-4\">\n              {safeFields.map((field) => renderFormField(field))}\n            </form>\n          </Form>\n        </CardContent>\n      </Card>\n\n      <div className=\"flex justify-end space-x-2\">\n        <Button\n          variant=\"outline\"\n          onClick={onCancel}\n          type=\"button\"\n          className=\"min-w-[100px]\"\n        >\n          {t('cancel')}\n        </Button>\n        <Button\n          onClick={form.handleSubmit(onSubmit)}\n          disabled={loading}\n          className=\"min-w-[100px]\"\n        >\n          {loading ? (\n            <div className=\"flex items-center justify-center\">\n              <div className=\"w-4 h-4 mr-2 border-t-2 border-b-2 border-current rounded-full animate-spin\" />\n              {t('creating')}\n            </div>\n          ) : (\n            t('create')\n          )}\n        </Button>\n      </div>\n    </div>\n  );\n};\n\nexport default ResourceCreate;",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/resource-create/messages/en.json",
      "content": "{\n  \"components\": {\n    \"resource-create\": {\n      \"add\": \"Add\",\n      \"need\": \"{label} is required\",\n      \"textlesser\": \"{label} must be less than {maxLength} characters\",\n      \"select\": \"Select {label}\",\n      \"successmessage\": \"Resource created successfully\",\n      \"errormessage\": \"An error occurred while creating the resource\",\n      \"created\": \"{resourceName} has been created\",\n      \"error\": \"Error\",\n      \"cancelcreate\": \"Resource creation canceled\",\n      \"cancel\": \"Cancel\",\n      \"creating\": \"Creating...\",\n      \"create\": \"Create\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-create/en.json"
    },
    {
      "path": "registry/new-york/blocks/resource-create/messages/ja.json",
      "content": "{\n  \"components\": {\n    \"resource-create\": {\n      \"add\": \"追加\",\n      \"need\": \"{label}は必須です\",\n      \"textlesser\": \"{label}は{maxLength}文字以下で入力してください\",\n      \"select\": \"{label}を選択\",\n      \"successmessage\": \"リソースが正常に作成されました\",\n      \"errormessage\": \"リソースの作成中にエラーが発生しました\",\n      \"created\": \"{resourceName}が作成されました\",\n      \"error\": \"エラー\",\n      \"cancelcreate\": \"リソース作成をキャンセルしました\",\n      \"cancel\": \"キャンセル\",\n      \"creating\": \"作成中...\",\n      \"create\": \"作成\"\n    }\n  }\n} ",
      "type": "registry:file",
      "target": "messages/components/resource-create/ja.json"
    }
  ]
}